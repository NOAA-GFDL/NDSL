import dataclasses
from typing import Tuple

import f90nml


DEFAULT_INT = 0
DEFAULT_STR = ""
DEFAULT_FLOAT = 0.0
DEFAULT_BOOL = False


# Global set of namelist defaults, attached to class for namespacing and static typing
class NamelistDefaults:
    dt_atmos: int = DEFAULT_INT
    npx: int = DEFAULT_INT
    npy: int = DEFAULT_INT
    npz: int = DEFAULT_INT
    layout: Tuple[int, int] = (1, 1)


@dataclasses.dataclass
class Namelist(f90nml.Namelist):
    dt_atmos: int = NamelistDefaults.dt_atmos
    npx: int = NamelistDefaults.npx
    npy: int = NamelistDefaults.npy
    npz: int = NamelistDefaults.npz
    layout: Tuple[int, int] = NamelistDefaults.layout

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # The following loop was generated by Gemini and vetted to
        # iterate through all namelist keys to update the dataclass fields.
        # If a parameter name matches our dataclass fields,
        # we update its value. We also keep track of values
        # we've found before to check for inconsistencies (in which
        # case, we raise a ValueError).
        config_fields = {f.name for f in dataclasses.fields(self)}
        seen_params = {}
        for group_name, group_params in self.items():
            for param_name, param_value in group_params.items():
                if param_name in config_fields:
                    if param_name in seen_params:
                        if seen_params[param_name] != param_value:
                            # If seen before with a differenv value, raise a ValueError
                            raise ValueError(
                                f"Inconsistent values found within namelist for '{param_name}'."
                            )
                    else:
                        # We're seeing this param for the first time, and we can update
                        # our field value.
                        seen_params[param_name] = param_value
                        setattr(self, param_name, param_value)

    def namelist_groups_to_flatish_dict(self, target_groups: list = None):
        """Returns a flat dict containing key-value pairs from the specified
        target_groups, along with the dataclass fields and values.

        Example: If the target_groups are ["coupler_nml", "fv_core_nml"],
        the returned flat dict would contain the key-value pairs from those groups
        only, along with the dataclass fields/values (e.g., dt_atmos).

        If no target_groups are specified, then the flattened return dict
        will pull from all groups, along with the dataclass fields and values.

        Raises ValueError if any duplicate keys from different groups have
        conflicting values, in which case we won't know which value to take.

        Args:
            target_groups: list of namelist groups (default is None)
        """

        if target_groups is None:
            extracted_nml = self
        else:
            # Disclaimer - This line was generated by Gemini and reviewed before use:
            extracted_groups = {
                group: self[group] for group in target_groups if group in self
            }
            extracted_nml = f90nml.Namelist(extracted_groups)

        flatish_dict = namelist_to_flatish_dict(extracted_nml)

        # Also, add in dataclass fields (self.npx, self.layout, etc.)
        for key in self.__dataclass_fields__:  # type: ignore
            flatish_dict[key] = getattr(self, key)
        return flatish_dict


def namelist_to_flatish_dict(nml_input):
    nml = dict(nml_input)
    for name, value in nml.items():
        if isinstance(value, f90nml.Namelist):
            nml[name] = namelist_to_flatish_dict(value)
    flatter_namelist = {}
    for key, value in nml.items():
        if isinstance(value, dict):
            for subkey, subvalue in value.items():
                if subkey in flatter_namelist:
                    raise ValueError(
                        "Cannot flatten this namelist, duplicate keys: " + subkey
                    )
                flatter_namelist[subkey] = subvalue
        else:
            flatter_namelist[key] = value
    return flatter_namelist
