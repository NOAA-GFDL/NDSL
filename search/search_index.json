{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NDSL Documentation","text":"<p>NDSL is a middleware for climate and weather modelling developed jointly by NOAA and NASA. It allows atmospheric scientists to focus on what matters in model development and essentially decouples performance engineering from model development.</p>"},{"location":"#portable-performance","title":"Portable performance","text":"<p>NDSL brings together GT4Py and DaCe, two libraries developed for high-performance and portability. On top of those pillars, NDSL deploys a series of optimized APIs for common operations, e.g. halo exchange or domain decomposition, and tools to port existing models.</p>"},{"location":"#batteries-included-for-fv-based-models","title":"Batteries-included for FV-based models","text":"<p>Historically, NDSL was developed to port the FV3 dynamical core on the cubed-sphere. Therefore, the middleware ships with ready-to-execute specialization for models based on cubed-sphere grids and FV-based models in particular.</p> <p>Next: get up and running.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Alright - let's get you up an running!</p> <p>NDSL requires Python version <code>3.11</code> and a GNU compiler. We strongly recommend using a conda or virtual environment.</p> <pre><code># We have submodules for GT4Py and DaCe. Don't forget to pull them\ngit clone --recurse-submodules git@github.com:NOAA-GFDL/NDSL.git\n\ncd NDSL/\n\n# We strongly recommend using conda or a virtual environment\npython -m venv .venv/\nsource ./venv/bin/activate\n\n# [optional] Install MPI if you don't have a system installation.\npip install openmpi\n\n# Finally, install NDSL\npip install .[demos]\n</code></pre> <p>Now you can run through the Jupyter notebooks in <code>examples/NDSL</code> .</p> <p>Read on in the user manual.</p> <p>Supported compilers</p> <p>NDSL currently only works with the GNU compiler. Using <code>clang</code> will result in errors related to undefined OpenMP flags.</p> <p>For MacOS users, we know that <code>gcc</code> version 14 from homebrew works.</p> <p>Why cloning the repository?</p> <p>We are cloning the repository because NDSL is not available on <code>pypi</code>.</p>"},{"location":"dev/","title":"Under the hood","text":"<p>This is the technical part of the documentation, geared towards developers contributing to NDSL.</p>"},{"location":"dev/#introduction","title":"Introduction","text":"<p>Recently, Python has became the dominant programming language in the machine learning and data sciences communities since it is easy to learn and program. However, the performance of Python is still a major concern in scientific computing and HPC community. In the scientific computing and HPC community, the most widely used programming languages are C/C++ and Fortran, Python is often used as script language for pre- and post-processing.</p> <p>The major performance issue in Python programming language, especially in computation-intensive applications, are loops, which are often the performance bottlenecks of an application in other programming languages too, such as C++ and Fortran. However, Python programs are often observed to be 10x to 100x slower than C, C++ and Fortran programs. In order to achieve peak hardware performance, the scientific computing communities have tried different programming models, such as OpenMP, Cilk+, and Thread Building Blocks (TBB), as well as Linux p-threads for multi/many-core processors and GPUs, Kokkos, RAJA, OpenMP offload, and OpenACC for highest performance on CPU/GPUs heterogeneous system. All of these programming models are only available for C, C++ and Fortran. Only a few work that target to high performance for Python programming language.</p> <p>The Python based NDSL programming model described in this developer\u2019s guide provides an alternative solution to reach peak hardware performance with relatively little programming effort by using the stencil semantics. A stencil is similar to parallel for kernels that are used in Kokkos and RAJA, to update array elements according to a fixed access pattern. With the stencil semantics in mind, NDSL, for example, can be used to write matrix multiplication kernels that match the performance of cuBLAS/hipBLAS that many GPU programmers can\u2019t do in Cuda/HiP using only about 30 lines of code. It greatly reduces the programmer\u2019s effort, and NDSL has already been successfully used in the Pace global climate model, which achieves up to 4x speedup, more efficient than the original Fortran implementations.</p>"},{"location":"dev/#programming-model","title":"Programming model","text":"<p>The programming model of NDSL is composed of backend execution spaces, performance optimization pass and transformations, and memory spaces, memory layout. These abstraction semantics allow the formulation of generic algorithms and data structures which can then be mapped to different types of hardware architectures. Effectively, they allow for compile time transformation of algorithms to allow for adaptions of varying degrees of hardware parallelism as well as of the memory hierarchy. Figure 1 shows the high level architecture of NDSL (without orchestration option), From Fig. 1, it is shown that NDSL uses hierarchy levels intermediate representation (IR) to abstract the structure of computational program, which reduces the complexity of application code, and maintenance cost, while the code portability and scalability are increased. This method also avoids raising the information from lower level representations by means of static analysis, and memory leaking, where feasible, and performing optimizations at the high possible level of abstraction. The methods primarily leverages structural information readily available in the source code, it enables to apply the optimization, such as loop fusion, tiling and vectorization without the need for complicated analysis and heuristics.</p> <p></p> <p>In NDSL, the python frontend code takes the user defined stencils to python AST using builtin ast module. In an AST, each node is an object defined in python AST grammar class (for more details, please refer: https://docs.python.org/3/library/ast.html). the AST node visitor (the NDSL/external/gt4py/src/gt4py/cartesian/frontend/gtscript_frontend.py) IRMaker class traverses the AST of a python function decorated by @gtscript.function and/or stencil objects, the Python AST of the program is then lowing to the Definition IR. The definition IR is high level IR, and is composed of high level program, domain-specific information, and the structure of computational operations which are independent of low level hardware platform. The definition of high level IR allows transformation of the IRs without loosing the performance of numerical libraries. However, the high level IR doesn\u2019t contains detailed information that required for performance on specific low level runtime hardware. Specifically, the definition IR only preserves the necessary information to lower operations to runtime platform hardware instructions implementing coarse-grained vector operations, or to numerical libraries \u2014 such as cuBLAS/hipBLAS and Intel MKL.</p> <p>The definition IR is then transformed to GTIR (gt4py/src/gt4py/cartesian/frontend/defir_to_gtir.py), the GTIR stencils is defined as in NDSL</p> <pre><code>class Stencil(LocNode, eve.ValidatedSymbolTableTrait):\n    name: str\n    api_signature: List[Argument]\n    params: List[Decl]\n    vertical_loops: List[VerticalLoop]\n    externals: Dict[str, Literal]\n    sources: Dict[str, str]\n    docstring: str\n\n    @property\n    def param_names(self) -&gt; List[str]:\n        return [p.name for p in self.params]\n\n    _validate_lvalue_dims = common.validate_lvalue_dims(VerticalLoop, FieldDecl)\n</code></pre> <p>GTIR is also a high level IR, it contains vertical_loops loop statement, in the climate applications, the vertical loops usually need special treatment as the numerical unstanbility is a reason. The vertical_loops in GTIR as separate code block and help the following performance pass and transformation implementation. The program analysis pass/transformation is applied on the GTIR to remove the redundant nodes, and pruning the unused parameters, and data type and shape propagations of the symbols, and loop extensions.</p> <p>The GTIR is then further lowered to optimization IR (OIR), which is defined as</p> <pre><code>class Stencil(LocNode, eve.ValidatedSymbolTableTrait):\n    name: str\n    # TODO: fix to be List[Union[ScalarDecl, FieldDecl]]\n    params: List[Decl]\n    vertical_loops: List[VerticalLoop]\n    declarations: List[Temporary]\n\n    _validate_dtype_is_set = common.validate_dtype_is_set()\n    _validate_lvalue_dims = common.validate_lvalue_dims(VerticalLoop, FieldDecl)\n</code></pre> <p>The OIR is particularly designed for performance optimization, the performance optimization algorithm are carried out on OIR by developing pass/transformations. Currently, the vertical loop merging, and horizontal execution loop merging, and loop unrolling and vectorization, statement fusion and pruning optimizations are available and activated by the environmental variable in the oir_pipeline module.</p> <p>After the optimization pipeline finished, the OIR is then converted to different backend IR, for example, DACE IR (SDFG). The DACE SDFG can be further optimized by its embedded pass/transformations algorithm, but in PACE application, we didn\u2019t activate this optimization step. It should be pointed out that, during the OIR to SDFG process, the horizontal execution node is serialized to SDFG library node, within which the loop expansion information is encrypted.</p> <p>When using GT backend, the OIR is then directly used by the gt4py code generator to generate the C++ GridTools stencils (computation code), and the python binding code. In this backend, each horizontal execution node will be passed to and generate a separate GridTools stencil.</p> <p>NDSL also supports the whole program optimization model, this is called orchestration model in NDSL, currently it only supports DaCe backend. Whole program optimization with DaCe is the process of turning all Python and GT4Py code in generated C++. Only orchestrate the runtime code of the model is applied, e.g. everything in the call method of the module and all code in init is executed like a normal GT backend.</p> <p>At the highest level in Pace, to turn on orchestration you need to flip the FV3_DACEMODE to an orchestrated options and run a dace:* backend (it will error out if run anything else). Option for FV3_DACEMODE are:</p> <ul> <li>Python: default, turns orchestration off.</li> <li>Build: build the SDFG then exit without running. See Build for limitation of build strategy.</li> <li>BuildAndRun: as above, but distribute the build and run.</li> <li>Run: tries to execute, errors out if the cache don\u2019t exists.</li> </ul> <p>Code is orchestrated two ways:</p> <ul> <li>functions are orchestrated via orchestrate_function decorator,</li> <li>methods are orchestrate via the orchestrate function (e.g. pace.driver.Driver._critical_path_step_all)</li> </ul> <p>The later is the way we orchestrate in our model. orchestrate is often called as the first function in the init. It patches in place the methods and replace them with a wrapper that will deal with turning it all into executable SDFG when call time comes.</p> <p>The orchestration has two parameters: config (will expand later) and dace_compiletime_args.</p> <p>DaCe needs to be described all memory so it can interface it in the C code that will be executed. Some memory is automatically parsed (e.g. numpy, cupy, scalars) and others need description. In our case Quantity and others need to be flag as dace.compiletime which tells DaCe to not try to AOT the memory and wait for JIT time. The dace_compiletime_args helps with tagging those without having to change the type hint.</p> <p>Figure 2 shows the hierarchy levels of intermediate representations (IR) and the lowing process when orchestration option is activated.</p> <p></p> <p>When the orchestrated option is turned on, the call method object is patched in place, replacing the original Callable with a wrapper that will trigger orchestration at call time. If the model configuration doesn\u2019t demand orchestration, this won\u2019t do anything. The orchestrated call methods and the computational stencils (lazy computational stencils) which are cached in a container, will be parsed to python AST by the frontend code during the runtime, then the python AST code will be converted to DaCe SDFG. The analysis and optimization will be applied before the C++ code is generated by the codegen, this process is called Just In Time (JIT) build, compared with the non-orchestration model, which is eagerly compiled and build. The JIT build caches the build information of computational stencils, and orchestrated methods, and it is more convenient to apply the analysis and optimization pass to the overall code, such as the merging of neighbor stencils made easy. Therefore, more optimized code can be generated, and better performance can be achieved during runtime.</p>"},{"location":"dev/#analysis-and-optimization","title":"Analysis and Optimization","text":"<p>One of the major features of NDSL is that users can develop a new pass/transformation for the backend with new hardware, the passes and/or transformations are the key integrates in order to have good performance on the new hardware. In different abstract level, the passes and/or transformations perform different levels of optimization. For example, the loop level of optimization is independent of hardware, and can be applied to any backend, while the optimization of device placement, and memory and caches optimizations are dependent on different backend and hardware. In this section, we only focused on the optimizations that are independent of the backend hardware.</p> <p>The general procedure of code optimization has two steps, in the first step, a filter function is called to find the pattern that need to apply the pass and/or transformation, then apply the pass and/or transformation to the filtered pattern to insert or delete or replace the existing node with the optimized node. In NDSL, the following passes and/transformations are provided.</p> <pre><code>def prune_unused_parameters(node: gtir.Stencil) -&gt; gtir.Stencil:\n      assert isinstance(node, gtir.Stencil)\n      used_variables = (\n        node.walk_values()\n        .if_isinstance(gtir.FieldAccess, gtir.ScalarAccess)\n        .getattr(\"name\")\n        .to_list()\n      )\n      used_params = list(filter(lambda param: param.name in used_variables, node.params))\n      return node.copy(update={\"params\": used_params})\n</code></pre>"},{"location":"dev/#code-generators","title":"Code generators","text":""},{"location":"dev/dace/","title":"DaCe","text":"<p>DaCe is is the full-program optimization framework used in NDSL. DaCe is short for Data-Centric Parallel Programming and developed at ETH's scalable parallel computing lab (SPCL).</p> <p>In NDSL, DaCe powers the performance backends of GT4Py. In particular, in NDSL's orchestration feature we will encode macro-level optimizations like loop re-ordering and stencil fusing using DaCe.</p>"},{"location":"dev/gt4py/","title":"GT4Py","text":"<p>Warning</p> <p>TODO: Add some docs on GT4Py here</p>"},{"location":"docstrings/","title":"Welcome to NDSL Docstrings","text":"<p>This documentation is generated from the docstrings of the various NDSL classes and functions.  It's organized by the various NDSL paths.</p> <ul> <li>Top level</li> <li>checkpointer</li> <li>comm</li> <li>debug</li> <li>dsl</li> <li>grid</li> <li>halo</li> <li>initialization</li> <li>monitor</li> <li>performance</li> <li>quantity</li> <li>restart</li> <li>stencils</li> <li>testing</li> <li>viz</li> </ul>"},{"location":"docstrings/checkpointer/base/","title":"base","text":""},{"location":"docstrings/checkpointer/null/","title":"null","text":""},{"location":"docstrings/checkpointer/snapshots/","title":"snapshots","text":""},{"location":"docstrings/checkpointer/snapshots/#checkpointer.snapshots.SnapshotCheckpointer","title":"<code>SnapshotCheckpointer</code>","text":"<p>               Bases: <code>Checkpointer</code></p> <p>Checkpointer which can be used to save datasets showing the evolution of variables between checkpointer calls.</p>"},{"location":"docstrings/checkpointer/snapshots/#checkpointer.snapshots.make_dims","title":"<code>make_dims(savepoint_dim, label, data_list)</code>","text":"<p>Helper which defines dimension names for an xarray variable.</p> <p>Used to ensure no dimensions have the same name but different sizes when defining xarray datasets.</p>"},{"location":"docstrings/checkpointer/thresholds/","title":"thresholds","text":""},{"location":"docstrings/checkpointer/thresholds/#checkpointer.thresholds.Threshold","title":"<code>Threshold</code>  <code>dataclass</code>","text":""},{"location":"docstrings/checkpointer/thresholds/#checkpointer.thresholds.Threshold.merge","title":"<code>merge(other)</code>","text":"<p>Provide a threshold which is always satisfied if both input thresholds are satisfied.</p> <p>This is generally a less strict threshold than either input.</p>"},{"location":"docstrings/checkpointer/thresholds/#checkpointer.thresholds.ThresholdCalibrationCheckpointer","title":"<code>ThresholdCalibrationCheckpointer</code>","text":"<p>               Bases: <code>Checkpointer</code></p> <p>Calibrates thresholds to be used by a ValidationCheckpointer.</p> <p>Does this by recording the minimum and maximum values seen across trials, and using them to derive the maximum relative and absolute error one could have across any pair of trials, then multiplying this by a user-provided factor.</p>"},{"location":"docstrings/checkpointer/thresholds/#checkpointer.thresholds.ThresholdCalibrationCheckpointer.__call__","title":"<code>__call__(savepoint_name, **kwargs)</code>","text":"<p>Record values for a savepoint.</p> <p>Parameters:</p> Name Type Description Default <code>savepoint_name</code> <code>SavepointName</code> <p>name of the savepoint</p> required <code>**kwargs</code> <code>ArrayLike</code> <p>data for the savepoint</p> <code>{}</code>"},{"location":"docstrings/checkpointer/thresholds/#checkpointer.thresholds.ThresholdCalibrationCheckpointer.__init__","title":"<code>__init__(factor=1.0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>factor</code> <code>float</code> <p>set thresholds equal to this factor of the maximum error seen across trials</p> <code>1.0</code>"},{"location":"docstrings/checkpointer/thresholds/#checkpointer.thresholds.ThresholdCalibrationCheckpointer.trial","title":"<code>trial()</code>","text":"<p>Context manager for a trial.</p> <p>A new context manager should entered each time the code being calibrated is called, and exited at the end of code execution. If each of these calls is done with slightly perturbed inputs, this calibrator will be able to estimate an error tolerance for each savepoint call.</p>"},{"location":"docstrings/checkpointer/validation/","title":"validation","text":""},{"location":"docstrings/checkpointer/validation/#checkpointer.validation.ValidationCheckpointer","title":"<code>ValidationCheckpointer</code>","text":"<p>               Bases: <code>Checkpointer</code></p> <p>Checkpointer which can be used to validate the output of a test.</p>"},{"location":"docstrings/checkpointer/validation/#checkpointer.validation.ValidationCheckpointer.__call__","title":"<code>__call__(savepoint_name, **kwargs)</code>","text":"<p>Checks the arrays passed as keyword arguments against thresholds specified.</p> <p>Parameters:</p> Name Type Description Default <code>savepoint_name</code> <code>str</code> <p>name of the savepoint</p> required <code>**kwargs</code> <code>ArrayLike</code> <p>array data for variables in that savepoint</p> <code>{}</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if the thresholds on any variable are not met</p>"},{"location":"docstrings/checkpointer/validation/#checkpointer.validation.ValidationCheckpointer.__init__","title":"<code>__init__(savepoint_data_path, thresholds, rank)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>savepoint_data_path</code> <code>str</code> <p>path to directory containing netcdf savepoint data</p> required <code>thresholds</code> <code>SavepointThresholds</code> <p>thresholds to check against</p> required <code>rank</code> <code>int</code> <p>rank of the process, needed to compare against the correct savepoint data</p> required"},{"location":"docstrings/checkpointer/validation/#checkpointer.validation.ValidationCheckpointer.trial","title":"<code>trial()</code>","text":"<p>Context manager for a trial.</p> <p>When entered, resets reference data comparison back to the start of the data.</p> <p>A new context manager should entered before the code being tested is called, and exited at the end of code execution.</p>"},{"location":"docstrings/comm/_boundary_utils/","title":"_boundary_utils","text":""},{"location":"docstrings/comm/_boundary_utils/#comm._boundary_utils.boundary_at_start_of_dim","title":"<code>boundary_at_start_of_dim(boundary, dim)</code>","text":"<p>Return True if boundary is at the start of the dimension, False if at the end, None if the boundary does not align with the dimension.</p>"},{"location":"docstrings/comm/boundary/","title":"boundary","text":""},{"location":"docstrings/comm/boundary/#comm.boundary.Boundary","title":"<code>Boundary</code>  <code>dataclass</code>","text":"<p>Maps part of a subtile domain to another rank which shares halo points.</p>"},{"location":"docstrings/comm/boundary/#comm.boundary.Boundary.n_clockwise_rotations","title":"<code>n_clockwise_rotations</code>  <code>instance-attribute</code>","text":"<p>number of clockwise rotations data undergoes if it moves from the from_rank to the to_rank. The same as the number of clockwise rotations to get from the orientation of the axes in from_rank to the orientation of the axes in to_rank.</p>"},{"location":"docstrings/comm/boundary/#comm.boundary.Boundary.recv_slice","title":"<code>recv_slice(specification)</code>","text":"<p>Return the index slices which should be received at this boundary.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <p>quantity for which to return slices</p> required <code>n_points</code> <p>the width of boundary to include</p> required <p>Returns:</p> Type Description <code>tuple[slice]</code> <p>A tuple of slices (one per dimensions)</p>"},{"location":"docstrings/comm/boundary/#comm.boundary.Boundary.recv_view","title":"<code>recv_view(quantity, n_points)</code>","text":"<p>Return a sliced view of points which should be received at this boundary.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>Quantity</code> <p>quantity for which to return a slice</p> required <code>n_points</code> <code>int</code> <p>the width of boundary to include</p> required"},{"location":"docstrings/comm/boundary/#comm.boundary.Boundary.send_slice","title":"<code>send_slice(specification)</code>","text":"<p>Return the index slices which should be sent at this boundary.</p> <p>Parameters:</p> Name Type Description Default <code>specification</code> <code>QuantityHaloSpec</code> <p>data specifications for the halo. Including shape</p> required <p>Returns:</p> Type Description <code>tuple[slice]</code> <p>A tuple of slices (one per dimensions)</p>"},{"location":"docstrings/comm/boundary/#comm.boundary.Boundary.send_view","title":"<code>send_view(quantity, n_points)</code>","text":"<p>Return a sliced view of points which should be sent at this boundary.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>Quantity</code> <p>quantity for which to return a slice</p> required <code>n_points</code> <code>int</code> <p>the width of boundary to include</p> required"},{"location":"docstrings/comm/boundary/#comm.boundary.SimpleBoundary","title":"<code>SimpleBoundary</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Boundary</code></p> <p>A boundary representing an edge or corner of a subtile.</p>"},{"location":"docstrings/comm/caching_comm/","title":"caching_comm","text":""},{"location":"docstrings/comm/caching_comm/#comm.caching_comm.CachingCommData","title":"<code>CachingCommData</code>  <code>dataclass</code>","text":"<p>Data required to restore a CachingCommReader.</p> <p>Usually you will not want to initialize this class directly, but instead use the CachingCommReader.load method.</p>"},{"location":"docstrings/comm/caching_comm/#comm.caching_comm.CachingCommReader","title":"<code>CachingCommReader</code>","text":"<p>               Bases: <code>Comm[T]</code></p> <p>mpi4py Comm-like object which replays stored communications.</p>"},{"location":"docstrings/comm/caching_comm/#comm.caching_comm.CachingCommReader.__init__","title":"<code>__init__(data)</code>","text":"<p>Initialize a CachingCommReader.</p> <p>Usually you will not want to initialize this class directly, but instead use the CachingCommReader.load method.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>CachingCommData</code> <p>contains all data needed for mocked communication</p> required"},{"location":"docstrings/comm/caching_comm/#comm.caching_comm.CachingCommWriter","title":"<code>CachingCommWriter</code>","text":"<p>               Bases: <code>Comm[T]</code></p> <p>Wrapper around a mpi4py Comm object which can be serialized and then loaded as a CachingCommReader.</p>"},{"location":"docstrings/comm/caching_comm/#comm.caching_comm.CachingCommWriter.__init__","title":"<code>__init__(comm)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>comm</code> <code>Comm[T]</code> <p>underlying mpi4py comm-like object</p> required"},{"location":"docstrings/comm/comm_abc/","title":"comm_abc","text":""},{"location":"docstrings/comm/communicator/","title":"communicator","text":""},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator","title":"<code>Communicator</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.boundaries","title":"<code>boundaries</code>  <code>property</code>","text":"<p>boundaries of this tile with neighboring tiles</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.rank","title":"<code>rank</code>  <code>property</code>","text":"<p>rank of the current process within this communicator</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.size","title":"<code>size</code>  <code>property</code>","text":"<p>Total number of ranks in this communicator</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.gather","title":"<code>gather(send_quantity, recv_quantity=None)</code>","text":"<p>Transfer subtile regions of a full-tile quantity from each rank to the tile root rank.</p> <p>Parameters:</p> Name Type Description Default <code>send_quantity</code> <code>Quantity</code> <p>quantity to send</p> required <code>recv_quantity</code> <code>Quantity | None</code> <p>if provided, assign received data into this Quantity (only used on the tile root rank)</p> <code>None</code> <p>Returns:     recv_quantity: quantity if on root rank, otherwise None</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.gather_state","title":"<code>gather_state(send_state=None, recv_state=None, transfer_type=None)</code>","text":"<p>Transfer a state dictionary from subtile ranks to the tile root rank.</p> <p>'time' is assumed to be the same on all ranks, and its value will be set to the value from the root rank.</p> <p>Parameters:</p> Name Type Description Default <code>send_state</code> <p>the model state to be sent containing the subtile data</p> <code>None</code> <code>recv_state</code> <p>the pre-allocated state in which to receive the full tile state. Only variables which are scattered will be written to.</p> <code>None</code> <p>Returns:     recv_state: on the root rank, the state containing the entire tile</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.halo_update","title":"<code>halo_update(quantity, n_points)</code>","text":"<p>Perform a halo update on a quantity or quantities</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>Quantity | list[Quantity]</code> <p>the quantity to be updated</p> required <code>n_points</code> <code>int</code> <p>how many halo points to update, starting from the interior</p> required"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.scatter","title":"<code>scatter(send_quantity=None, recv_quantity=None)</code>","text":"<p>Transfer subtile regions of a full-tile quantity from the tile root rank to all subtiles.</p> <p>Parameters:</p> Name Type Description Default <code>send_quantity</code> <code>Quantity | None</code> <p>quantity to send, only required/used on the tile root rank</p> <code>None</code> <code>recv_quantity</code> <code>Quantity | None</code> <p>if provided, assign received data into this Quantity.</p> <code>None</code> <p>Returns:     recv_quantity</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.scatter_state","title":"<code>scatter_state(send_state=None, recv_state=None)</code>","text":"<p>Transfer a state dictionary from the tile root rank to all subtiles.</p> <p>Parameters:</p> Name Type Description Default <code>send_state</code> <p>the model state to be sent containing the entire tile, required only from the root rank</p> <code>None</code> <code>recv_state</code> <p>the pre-allocated state in which to receive the scattered state. Only variables which are scattered will be written to.</p> <code>None</code> <p>Returns:     rank_state: the state corresponding to this rank's subdomain</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.start_halo_update","title":"<code>start_halo_update(quantity, n_points)</code>","text":"<p>Start an asynchronous halo update on a quantity.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>Quantity | list[Quantity]</code> <p>the quantity to be updated</p> required <code>n_points</code> <code>int</code> <p>how many halo points to update, starting from the interior</p> required <p>Returns:</p> Name Type Description <code>request</code> <code>HaloUpdater</code> <p>an asynchronous request object with a .wait() method</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.start_synchronize_vector_interfaces","title":"<code>start_synchronize_vector_interfaces(x_quantity, y_quantity)</code>","text":"<p>Synchronize shared points at the edges of a vector interface variable.</p> <p>Sends the values on the south and west edges to overwrite the values on adjacent subtiles. Vector must be defined on the Arakawa C grid.</p> <p>For interface variables, the edges of the tile are computed on both ranks bordering that edge. This routine copies values across those shared edges so that both ranks have the same value for that edge. It also handles any rotation of vector quantities needed to move data across the edge.</p> <p>Parameters:</p> Name Type Description Default <code>x_quantity</code> <code>Quantity</code> <p>the x-component quantity to be synchronized</p> required <code>y_quantity</code> <code>Quantity</code> <p>the y-component quantity to be synchronized</p> required <p>Returns:</p> Name Type Description <code>request</code> <code>HaloUpdateRequest</code> <p>an asynchronous request object with a .wait() method</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.start_vector_halo_update","title":"<code>start_vector_halo_update(x_quantity, y_quantity, n_points)</code>","text":"<p>Start an asynchronous halo update of a horizontal vector quantity.</p> <p>Assumes the x and y dimension indices are the same between the two quantities.</p> <p>Parameters:</p> Name Type Description Default <code>x_quantity</code> <code>Quantity | list[Quantity]</code> <p>the x-component quantity to be halo updated</p> required <code>y_quantity</code> <code>Quantity | list[Quantity]</code> <p>the y-component quantity to be halo updated</p> required <code>n_points</code> <code>int</code> <p>how many halo points to update, starting at the interior</p> required <p>Returns:</p> Name Type Description <code>request</code> <code>HaloUpdater</code> <p>an asynchronous request object with a .wait() method</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.synchronize_vector_interfaces","title":"<code>synchronize_vector_interfaces(x_quantity, y_quantity)</code>","text":"<p>Synchronize shared points at the edges of a vector interface variable.</p> <p>Sends the values on the south and west edges to overwrite the values on adjacent subtiles. Vector must be defined on the Arakawa C grid.</p> <p>For interface variables, the edges of the tile are computed on both ranks bordering that edge. This routine copies values across those shared edges so that both ranks have the same value for that edge. It also handles any rotation of vector quantities needed to move data across the edge.</p> <p>Parameters:</p> Name Type Description Default <code>x_quantity</code> <code>Quantity</code> <p>the x-component quantity to be synchronized</p> required <code>y_quantity</code> <code>Quantity</code> <p>the y-component quantity to be synchronized</p> required"},{"location":"docstrings/comm/communicator/#comm.communicator.Communicator.vector_halo_update","title":"<code>vector_halo_update(x_quantity, y_quantity, n_points)</code>","text":"<p>Perform a halo update of a horizontal vector quantity or quantities.</p> <p>Assumes the x and y dimension indices are the same between the two quantities.</p> <p>Parameters:</p> Name Type Description Default <code>x_quantity</code> <code>Quantity | list[Quantity]</code> <p>the x-component quantity to be halo updated</p> required <code>y_quantity</code> <code>Quantity | list[Quantity]</code> <p>the y-component quantity to be halo updated</p> required <code>n_points</code> <code>int</code> <p>how many halo points to update, starting at the interior</p> required"},{"location":"docstrings/comm/communicator/#comm.communicator.CubedSphereCommunicator","title":"<code>CubedSphereCommunicator</code>","text":"<p>               Bases: <code>Communicator</code></p> <p>Performs communications within a cubed sphere</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.CubedSphereCommunicator.tile","title":"<code>tile</code>  <code>property</code>","text":"<p>communicator for within a tile</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.CubedSphereCommunicator.__init__","title":"<code>__init__(comm, partitioner, force_cpu=False, timer=None)</code>","text":"<p>Initialize a CubedSphereCommunicator.</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>Comm</code> <p>mpi4py.Comm object</p> required <code>partitioner</code> <code>CubedSpherePartitioner</code> <p>cubed sphere partitioner</p> required <code>force_cpu</code> <code>bool</code> <p>Force all communication to go through central memory.</p> <code>False</code> <code>timer</code> <code>Timer | None</code> <p>Time communication operations.</p> <code>None</code>"},{"location":"docstrings/comm/communicator/#comm.communicator.TileCommunicator","title":"<code>TileCommunicator</code>","text":"<p>               Bases: <code>Communicator</code></p> <p>Performs communications within a single tile or region of a tile</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.TileCommunicator.__init__","title":"<code>__init__(comm, partitioner, force_cpu=False, timer=None)</code>","text":"<p>Initialize a TileCommunicator.</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>Comm</code> <p>communication object behaving like mpi4py.Comm</p> required <code>partitioner</code> <code>TilePartitioner</code> <p>tile partitioner</p> required <code>force_cpu</code> <code>bool</code> <p>force all communication to go through central memory</p> <code>False</code> <code>timer</code> <code>Timer | None</code> <p>Time communication operations.</p> <code>None</code>"},{"location":"docstrings/comm/communicator/#comm.communicator.TileCommunicator.start_halo_update","title":"<code>start_halo_update(quantity, n_points)</code>","text":"<p>Start an asynchronous halo update on a quantity.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>Quantity | list[Quantity]</code> <p>the quantity to be updated</p> required <code>n_points</code> <code>int</code> <p>how many halo points to update, starting from the interior</p> required <p>Returns:</p> Name Type Description <code>request</code> <code>HaloUpdater</code> <p>an asynchronous request object with a .wait() method</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.TileCommunicator.start_synchronize_vector_interfaces","title":"<code>start_synchronize_vector_interfaces(x_quantity, y_quantity)</code>","text":"<p>Synchronize shared points at the edges of a vector interface variable.</p> <p>Sends the values on the south and west edges to overwrite the values on adjacent subtiles. Vector must be defined on the Arakawa C grid.</p> <p>For interface variables, the edges of the tile are computed on both ranks bordering that edge. This routine copies values across those shared edges so that both ranks have the same value for that edge. It also handles any rotation of vector quantities needed to move data across the edge.</p> <p>Parameters:</p> Name Type Description Default <code>x_quantity</code> <code>Quantity</code> <p>the x-component quantity to be synchronized</p> required <code>y_quantity</code> <code>Quantity</code> <p>the y-component quantity to be synchronized</p> required <p>Returns:</p> Name Type Description <code>request</code> <code>HaloUpdateRequest</code> <p>an asynchronous request object with a .wait() method</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.TileCommunicator.start_vector_halo_update","title":"<code>start_vector_halo_update(x_quantity, y_quantity, n_points)</code>","text":"<p>Start an asynchronous halo update of a horizontal vector quantity.</p> <p>Assumes the x and y dimension indices are the same between the two quantities.</p> <p>Parameters:</p> Name Type Description Default <code>x_quantity</code> <code>Quantity | list[Quantity]</code> <p>the x-component quantity to be halo updated</p> required <code>y_quantity</code> <code>Quantity | list[Quantity]</code> <p>the y-component quantity to be halo updated</p> required <code>n_points</code> <code>int</code> <p>how many halo points to update, starting at the interior</p> required <p>Returns:</p> Name Type Description <code>request</code> <code>HaloUpdater</code> <p>an asynchronous request object with a .wait() method</p>"},{"location":"docstrings/comm/communicator/#comm.communicator.to_numpy","title":"<code>to_numpy(array, dtype=None)</code>","text":"<p>Input array can be a numpy array or a cupy array. Returns numpy array.</p>"},{"location":"docstrings/comm/decomposition/","title":"decomposition","text":""},{"location":"docstrings/comm/decomposition/#comm.decomposition.block_waiting_for_compilation","title":"<code>block_waiting_for_compilation(comm, compilation_config)</code>","text":"<p>block moving on until an ok is received from the compiling rank</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>Comm</code> <p>communicator over which the ok is sent</p> required <code>stencil_config</code> <code>CompilationConfig</code> <p>holding communicator and rank information</p> required"},{"location":"docstrings/comm/decomposition/#comm.decomposition.build_cache_path","title":"<code>build_cache_path(config)</code>","text":"<p>generate the GT-Cache path from the config</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CompilationConfig</code> <p>stencil-config object at post-init state</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str, str]: path and individual rank string</p>"},{"location":"docstrings/comm/decomposition/#comm.decomposition.determine_rank_is_compiling","title":"<code>determine_rank_is_compiling(rank, size)</code>","text":"<p>Determines if a rank needs to be a compiling one</p> <p>Parameters:</p> Name Type Description Default <code>rank</code> <code>int</code> <p>current rank</p> required <code>size</code> <code>int</code> <p>size of the communicator</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the rank is a compiling one</p>"},{"location":"docstrings/comm/decomposition/#comm.decomposition.set_distributed_caches","title":"<code>set_distributed_caches(config)</code>","text":"<p>In Run mode, check required file then point current rank cache to source cache</p>"},{"location":"docstrings/comm/decomposition/#comm.decomposition.unblock_waiting_tiles","title":"<code>unblock_waiting_tiles(comm)</code>","text":"<p>sends a message to all the ranks waiting for compilation to finish</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>Comm</code> <p>communicator over which the ok is sent</p> required"},{"location":"docstrings/comm/local_comm/","title":"local_comm","text":""},{"location":"docstrings/comm/local_comm/#comm.local_comm.ConcurrencyError","title":"<code>ConcurrencyError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception to denote that a rank cannot proceed because it is waiting on a call from another rank.</p>"},{"location":"docstrings/comm/mpi/","title":"mpi","text":"<p>Wrapper around mpi4py.</p> <p>This module defines a light-weight wrapper around mpi4py. It is the only place where we directly import from mpi4py. This allows to potentially swap mpi4py in the future.</p>"},{"location":"docstrings/comm/null_comm/","title":"null_comm","text":""},{"location":"docstrings/comm/null_comm/#comm.null_comm.NullComm","title":"<code>NullComm</code>","text":"<p>               Bases: <code>Comm[T]</code></p> <p>A class with a subset of the mpi4py Comm API, but which 'receives' a fill value (default zero) instead of using MPI.</p>"},{"location":"docstrings/comm/null_comm/#comm.null_comm.NullComm.__init__","title":"<code>__init__(rank, total_ranks, fill_value=default_fill_value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>rank</code> <code>int</code> <p>rank to mock</p> required <code>total_ranks</code> <code>int</code> <p>number of total MPI ranks to mock</p> required <code>fill_value</code> <code>T</code> <p>fill halos with this value when performing halo updates.</p> <code>default_fill_value</code>"},{"location":"docstrings/comm/partitioner/","title":"partitioner","text":""},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner","title":"<code>CubedSpherePartitioner</code>","text":"<p>               Bases: <code>Partitioner</code></p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner.total_ranks","title":"<code>total_ranks</code>  <code>property</code>","text":"<p>the number of ranks on the cubed sphere</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner.__init__","title":"<code>__init__(tile)</code>","text":"<p>Create an object for fv3gfs cubed-sphere domain decomposition.</p> <p>Parameters:</p> Name Type Description Default <code>tile</code> <code>TilePartitioner</code> <p>partitioner for the cube faces</p> required"},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner.boundary","title":"<code>boundary(boundary_type, rank)</code>","text":"<p>Returns a boundary of the requested type for a given rank, or None.</p> <p>On tile corners, the boundary across that corner does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>boundary_type</code> <code>int</code> <p>the type of boundary</p> required <code>rank</code> <code>int</code> <p>the processor rank</p> required <p>Returns:</p> Type Description <code>SimpleBoundary | None</code> <p>boundary</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner.from_namelist","title":"<code>from_namelist(namelist)</code>  <code>classmethod</code>","text":"<p>Initialize a CubedSpherePartitioner from a Fortran namelist.</p> <p>Parameters:</p> Name Type Description Default <code>namelist</code> <code>dict</code> <p>the Fortran namelist</p> required"},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner.global_extent","title":"<code>global_extent(rank_metadata)</code>","text":"<p>Return the shape of a full cube representation for the given dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <p>quantity metadata</p> required <p>Returns:</p> Name Type Description <code>extent</code> <code>tuple[int, ...]</code> <p>shape of full cube representation</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner.subtile_extent","title":"<code>subtile_extent(cube_metadata, rank)</code>","text":"<p>Return the shape of a single rank representation for the given dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>global_metadata</code> <p>quantity metadata.</p> required <code>rank</code> <code>int</code> <p>rank of the process.</p> required <p>Returns:</p> Name Type Description <code>extent</code> <code>tuple[int, ...]</code> <p>shape of a single rank representation for the given dimensions.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner.subtile_slice","title":"<code>subtile_slice(rank, global_dims, global_extent, overlap=False)</code>","text":"<p>Return the subtile slice of a given rank on an array.</p> <p>Global refers to the domain being partitioned. For example, for a partitioning of a tile, the tile would be the \"global\" domain.</p> <p>Parameters:</p> Name Type Description Default <code>rank</code> <code>int</code> <p>the rank of the process</p> required <code>global_dims</code> <code>Sequence[str]</code> <p>dimensions of the global quantity being partitioned</p> required <code>global_extent</code> <code>Sequence[int]</code> <p>extent of the global quantity being partitioned</p> required <code>overlap</code> <code>optional</code> <p>if True, for interface variables include the part of the array shared by adjacent ranks in both ranks. If False, ensure only one of those ranks (the greater rank) is assigned the overlapping section. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>subtile_slice</code> <code>tuple[int | slice, ...]</code> <p>the tuple slice of the global compute domain corresponding to the subtile compute domain</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner.tile_index","title":"<code>tile_index(rank)</code>","text":"<p>Returns the tile index of a given rank</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.CubedSpherePartitioner.tile_root_rank","title":"<code>tile_root_rank(rank)</code>","text":"<p>Returns the lowest rank on the same tile as a given rank.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.Partitioner","title":"<code>Partitioner</code>","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.Partitioner.global_extent","title":"<code>global_extent(rank_metadata)</code>  <code>abstractmethod</code>","text":"<p>Return the shape of a full tile representation for the given dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <p>quantity metadata</p> required <p>Returns:</p> Name Type Description <code>extent</code> <code>tuple[int, ...]</code> <p>shape of full tile representation</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.Partitioner.subtile_extent","title":"<code>subtile_extent(global_metadata, rank)</code>  <code>abstractmethod</code>","text":"<p>Return the shape of a single rank representation for the given dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>global_metadata</code> <code>QuantityMetadata</code> <p>quantity metadata.</p> required <code>rank</code> <code>int</code> <p>rank of the process.</p> required <p>Returns:</p> Name Type Description <code>extent</code> <code>tuple[int, ...]</code> <p>shape of a single rank representation for the given dimensions.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.Partitioner.subtile_slice","title":"<code>subtile_slice(rank, global_dims, global_extent, overlap=False)</code>  <code>abstractmethod</code>","text":"<p>Return the subtile slice of a given rank on an array.</p> <p>Global refers to the domain being partitioned. For example, for a partitioning of a tile, the tile would be the \"global\" domain.</p> <p>Parameters:</p> Name Type Description Default <code>rank</code> <code>int</code> <p>the rank of the process</p> required <code>global_dims</code> <code>Sequence[str]</code> <p>dimensions of the global quantity being partitioned</p> required <code>global_extent</code> <code>Sequence[int]</code> <p>extent of the global quantity being partitioned</p> required <code>overlap</code> <code>optional</code> <p>if True, for interface variables include the part of the array shared by adjacent ranks in both ranks. If False, ensure only one of those ranks (the greater rank) is assigned the overlapping section. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>subtile_slice</code> <code>tuple[int | slice, ...]</code> <p>the slice of the global compute domain corresponding to the subtile compute domain</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.TilePartitioner","title":"<code>TilePartitioner</code>","text":"<p>               Bases: <code>Partitioner</code></p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.TilePartitioner.__init__","title":"<code>__init__(layout, edge_interior_ratio=1.0)</code>","text":"<p>Create an object for fv3gfs tile decomposition.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.TilePartitioner.boundary","title":"<code>boundary(boundary_type, rank)</code>","text":"<p>Returns a boundary of the requested type for a given rank.</p> <p>Target ranks will be on the same tile as the given rank, wrapping around as in a doubly-periodic boundary condition.</p> <p>Parameters:</p> Name Type Description Default <code>boundary_type</code> <code>int</code> <p>the type of boundary</p> required <code>rank</code> <code>int</code> <p>the processor rank</p> required <p>Returns:</p> Type Description <code>SimpleBoundary | None</code> <p>boundary</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.TilePartitioner.from_namelist","title":"<code>from_namelist(namelist)</code>  <code>classmethod</code>","text":"<p>Initialize a TilePartitioner from a Fortran namelist.</p> <p>Parameters:</p> Name Type Description Default <code>namelist</code> <code>dict</code> <p>the Fortran namelist</p> required"},{"location":"docstrings/comm/partitioner/#comm.partitioner.TilePartitioner.global_extent","title":"<code>global_extent(rank_metadata)</code>","text":"<p>Return the shape of a full tile representation for the given dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <p>quantity metadata</p> required <p>Returns:</p> Name Type Description <code>extent</code> <code>tuple[int, ...]</code> <p>shape of full tile representation</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.TilePartitioner.subtile_extent","title":"<code>subtile_extent(global_metadata, rank)</code>","text":"<p>Return the shape of a single rank representation for the given dimensions.</p> <p>Parameters:</p> Name Type Description Default <code>global_metadata</code> <code>QuantityMetadata</code> <p>quantity metadata.</p> required <code>rank</code> <code>int</code> <p>rank of the process.</p> required <p>Returns:</p> Name Type Description <code>extent</code> <code>tuple[int, ...]</code> <p>shape of a single rank representation for the given dimensions.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.TilePartitioner.subtile_index","title":"<code>subtile_index(rank)</code>","text":"<p>Return the (y, x) subtile position of a given rank as an integer number of subtiles.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.TilePartitioner.subtile_slice","title":"<code>subtile_slice(rank, global_dims, global_extent, overlap=False)</code>","text":"<p>Return the subtile slice of a given rank on an array.</p> <p>Global refers to the domain being partitioned. For example, for a partitioning of a tile, the tile would be the \"global\" domain.</p> <p>Parameters:</p> Name Type Description Default <code>rank</code> <code>int</code> <p>the rank of the process</p> required <code>global_dims</code> <code>Sequence[str]</code> <p>dimensions of the global quantity being partitioned</p> required <code>global_extent</code> <code>Sequence[int]</code> <p>extent of the global quantity being partitioned</p> required <code>overlap</code> <code>optional</code> <p>if True, for interface variables include the part of the array shared by adjacent ranks in both ranks. If False, ensure only one of those ranks (the greater rank) is assigned the overlapping section. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>subtile_slice</code> <code>tuple[slice, ...]</code> <p>the slice of the global compute domain corresponding to the subtile compute domain</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.fliplr_subtile_rank","title":"<code>fliplr_subtile_rank(rank, layout)</code>","text":"<p>Returns the rank position where this rank would be if you flipped the tile along a vertical axis</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.flipud_subtile_rank","title":"<code>flipud_subtile_rank(rank, layout)</code>","text":"<p>Returns the rank position where this rank would be if you flipped the tile along a horizontal axis</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.get_tile_index","title":"<code>get_tile_index(rank, total_ranks)</code>","text":"<p>Returns the zero-indexed tile number, given a rank and total number of ranks.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.get_tile_number","title":"<code>get_tile_number(tile_rank, total_ranks)</code>","text":"<p>Deprecated: use get_tile_index.</p> <p>Returns the tile number for a given rank and total number of ranks.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.rotate_subtile_rank","title":"<code>rotate_subtile_rank(rank, layout, n_clockwise_rotations)</code>","text":"<p>Returns the rank position where this rank would be if you rotated the tile n_clockwise_rotations times.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.subtile_slice","title":"<code>subtile_slice(dims, global_extent, layout, subtile_index, edge_interior_ratio=1.0, overlap=False)</code>","text":"<p>Returns the slice of data within a tile's computational domain belonging to a single rank.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Sequence[str]</code> <p>dimension names for each axis</p> required <code>global_extent</code> <code>Sequence[int]</code> <p>size of the tile or cube's computational domain</p> required <code>layout</code> <code>tuple[int, int]</code> <p>the (y, x) number of ranks along each tile axis</p> required <code>subtile_index</code> <code>tuple[int, int]</code> <p>the (y, x) position of the rank on the tile</p> required <code>edge_interior_ratio</code> <code>float</code> <p>target value for the relative 1-dimensional extent of the compute domains of ranks on tile edges and corners compared to ranks on the tile interior. In all cases, the closest valid value will be used, which enables some previously invalid configurations (e.g. C128 on a 3 by 3 layout will use the closest valid edge_interior_ratio to 1.0).</p> <code>1.0</code> <code>overlap</code> <code>optional</code> <p>if True, for interface variables include the part of the array shared by adjacent ranks in both ranks. If False, ensure only one of those ranks (the greater rank) is assigned the overlapping section. Default is False.</p> <code>False</code>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.tile_extent_from_rank_metadata","title":"<code>tile_extent_from_rank_metadata(dims, rank_extent, layout, edge_interior_ratio=1.0)</code>","text":"<p>Returns the extent of a tile given data about a single rank, and the tile layout.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Sequence[str]</code> <p>dimension names</p> required <code>rank_extent</code> <code>Sequence[int]</code> <p>the extent of one rank</p> required <code>layout</code> <code>tuple[int, int]</code> <p>the (y, x) number of ranks along each tile axis</p> required <code>edge_interior_ratio</code> <code>float</code> <p>target value for the relative 1-dimensional extent of the compute domains of ranks on tile edges and corners compared to ranks on the tile interior. In all cases, the closest valid value will be used, which enables some previously invalid configurations (e.g. C128 on a 3 by 3 layout will use the closest valid edge_interior_ratio to 1.0).</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>tile_extent</code> <code>tuple[int, ...]</code> <p>the extent of one tile</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.transform_subtile_rank","title":"<code>transform_subtile_rank(transform_func, rank, layout)</code>","text":"<p>Returns the rank position where this rank would be if you performed a transformation on the tile which strictly moves ranks.</p>"},{"location":"docstrings/comm/partitioner/#comm.partitioner.transpose_subtile_rank","title":"<code>transpose_subtile_rank(rank, layout)</code>","text":"<p>Returns the rank position where this rank would be if you transposed the tile.</p>"},{"location":"docstrings/debug/config/","title":"config","text":"<p>This module provides configuration for the global debugger <code>ndsl_debugger</code></p> <p>When loading, the configuration will be searched in the global environment variable <code>NDSL_DEBUG_CONFIG</code></p> <p>Configuration is a yaml file of the shape <pre><code>stencils_or_class:\n  - copy_corners_x_nord\n  - copy_corners_y_nord\n  - DGridShallowWaterLagrangianDynamics.__call__\ntrack_parameter_by_name:\n  - fy\n</code></pre></p> <p>Global variable</p> <p>ndsl_debugger: Debugger accessible throughout the middleware, default to <code>None</code>     if there is no configuration</p>"},{"location":"docstrings/debug/debugger/","title":"debugger","text":""},{"location":"docstrings/debug/debugger/#debug.debugger.Debugger","title":"<code>Debugger</code>  <code>dataclass</code>","text":"<p>Debugger relying on <code>ndsl.debug.config</code> for setup capable of doing automatic data save on external configuration.</p>"},{"location":"docstrings/debug/debugger/#debug.debugger.Debugger.increment_call_count","title":"<code>increment_call_count(savename)</code>","text":"<p>Increment the call count for this savename</p>"},{"location":"docstrings/debug/debugger/#debug.debugger.Debugger.save_as_dataset","title":"<code>save_as_dataset(data_as_dict, savename, is_in)</code>","text":"<p>Save dictionary of data to NetCDF</p> <p>Note: Unknown types in the dictionary won't be saved.</p>"},{"location":"docstrings/debug/tooling/","title":"tooling","text":""},{"location":"docstrings/dsl/gt4py_utils/","title":"gt4py_utils","text":""},{"location":"docstrings/dsl/gt4py_utils/#dsl.gt4py_utils.make_storage_data","title":"<code>make_storage_data(data, shape=None, origin=origin, *, backend, dtype=Float, mask=None, start=(0, 0, 0), dummy=None, axis=2, max_dim=3, read_only=True)</code>","text":"<p>Create a new gt4py storage from the given data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArray</code> <p>Data array for new storage</p> required <code>shape</code> <code>tuple[int, ...] | None</code> <p>Shape of the new storage. Number of indices should be equal to number of unmasked axes</p> <code>None</code> <code>origin</code> <code>tuple[int, ...]</code> <p>Default origin for gt4py stencil calls</p> <code>origin</code> <code>dtype</code> <code>DTypes</code> <p>Data type</p> <code>Float</code> <code>mask</code> <code>tuple[bool, ...] | None</code> <p>Tuple indicating the axes used when initializing the storage. True indicates a masked axis, False is a used axis.</p> <code>None</code> <code>start</code> <code>tuple[int, ...]</code> <p>Starting points for slices in data copies</p> <code>(0, 0, 0)</code> <code>dummy</code> <code>tuple[int, ...] | None</code> <p>Dummy axes</p> <code>None</code> <code>axis</code> <code>int</code> <p>Axis for 2D to 3D arrays</p> <code>2</code> <code>backend</code> <code>str</code> <p>gt4py backend to use</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Field[..., dtype]: New storage</p> <p>Examples:</p> <p>1) ptop = utils.make_storage_data(top_p, q4_1.shape) 2) ws3 = utils.make_storage_data(ws3[:, :, -1], shape, origin=(0, 0, 0)) 3) data_dict[names[i]] = make_storage_data(        data[:, :, :, i],        shape,        origin=origin,        start=start,        dummy=dummy,        axis=axis,    )</p>"},{"location":"docstrings/dsl/gt4py_utils/#dsl.gt4py_utils.make_storage_from_shape","title":"<code>make_storage_from_shape(shape, origin=origin, *, backend, dtype=Float, mask=None)</code>","text":"<p>Create a new gt4py storage of a given shape filled with zeros.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple[int, ...]</code> <p>Shape of the new storage</p> required <code>origin</code> <code>tuple[int, ...]</code> <p>Default origin for gt4py stencil calls</p> <code>origin</code> <code>dtype</code> <code>DTypes</code> <p>Data type</p> <code>Float</code> <code>mask</code> <code>tuple[bool, ...] | None</code> <p>Tuple indicating the axes used when initializing the storage</p> <code>None</code> <code>backend</code> <code>str</code> <p>gt4py backend to use when making the storage</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>Field[..., dtype]: New storage</p> <p>Examples:</p> <p>1) utmp = utils.make_storage_from_shape(ua.shape) 2) qx = utils.make_storage_from_shape(        qin.shape, origin=(grid().is_, grid().jsd, kstart)    ) 3) q_out = utils.make_storage_from_shape(q_in.shape, origin,)</p>"},{"location":"docstrings/dsl/gt4py_utils/#dsl.gt4py_utils.split_cartesian_into_storages","title":"<code>split_cartesian_into_storages(var)</code>","text":"<p>Provided a storage of dims [X_DIM, Y_DIM, CARTESIAN_DIM]      or [X_INTERFACE_DIM, Y_INTERFACE_DIM, CARTESIAN_DIM] Split it into separate 2D storages for each cartesian dimension, and return these in a list.</p>"},{"location":"docstrings/dsl/stencil/","title":"stencil","text":""},{"location":"docstrings/dsl/stencil/#dsl.stencil.CompareToNumpyStencil","title":"<code>CompareToNumpyStencil</code>","text":"<p>A wrapper over FrozenStencil which executes a numpy version of the stencil as well, and compares the results.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.FrozenStencil","title":"<code>FrozenStencil</code>","text":"<p>               Bases: <code>SDFGConvertible</code></p> <p>Wrapper for gt4py stencils which stores origin and domain at compile time, and uses their stored values at call time.</p> <p>This is useful when the stencil itself is meant to be used on a certain grid, for example if a compile-time external variable is tied to the values of origin and domain.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.FrozenStencil.__init__","title":"<code>__init__(func, origin, domain, stencil_config, externals=None, skip_passes=(), timing_collector=None, comm=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., None]</code> <p>stencil definition function</p> required <code>origin</code> <code>tuple[int, ...] | Mapping[str, tuple[int, ...]]</code> <p>gt4py origin to use at call time</p> required <code>domain</code> <code>tuple[int, ...]</code> <p>gt4py domain to use at call time</p> required <code>stencil_config</code> <code>StencilConfig</code> <p>container for stencil configuration</p> required <code>externals</code> <code>Mapping[str, Any] | None</code> <p>compile-time external variables required by stencil</p> <code>None</code> <code>skip_passes</code> <code>tuple[str, ...]</code> <p>compiler passes to skip when building stencil</p> <code>()</code> <code>timing_collector</code> <code>TimingCollector | None</code> <p>Optional object that accumulates timings</p> <code>None</code> <code>comm</code> <code>Comm | None</code> <p>if given, inputs and outputs will be compared to the \"twin\" rank of this rank</p> <code>None</code>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.FrozenStencil.__sdfg__","title":"<code>__sdfg__(*args, **kwargs)</code>","text":"<p>Implemented SDFG generation</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.FrozenStencil.__sdfg_closure__","title":"<code>__sdfg_closure__(*args, **kwargs)</code>","text":"<p>Implemented SDFG closure build</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.FrozenStencil.__sdfg_signature__","title":"<code>__sdfg_signature__()</code>","text":"<p>Implemented SDFG signature lookup</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.FrozenStencil.closure_resolver","title":"<code>closure_resolver(constant_args, given_args, parent_closure=None)</code>","text":"<p>Implemented SDFG closure resolver build</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing","title":"<code>GridIndexing</code>","text":"<p>Provides indices for cell-centered variables with halos.</p> <p>These indices can be used with horizontal interface variables by adding 1 to the domain shape along any interface axis.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.iec","title":"<code>iec</code>  <code>property</code>","text":"<p>Last index of the compute domain along the x-axis</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.ied","title":"<code>ied</code>  <code>property</code>","text":"<p>Index of the last data point along the x-axis</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.isc","title":"<code>isc</code>  <code>property</code>","text":"<p>Start of the compute domain along the x-axis</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.isd","title":"<code>isd</code>  <code>property</code>","text":"<p>Start of the full domain including halos along the x-axis</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.jec","title":"<code>jec</code>  <code>property</code>","text":"<p>Last index of the compute domain along the y-axis</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.jed","title":"<code>jed</code>  <code>property</code>","text":"<p>Index of the last data point along the y-axis</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.jsc","title":"<code>jsc</code>  <code>property</code>","text":"<p>Start of the compute domain along the y-axis</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.jsd","title":"<code>jsd</code>  <code>property</code>","text":"<p>Start of the full domain including halos along the y-axis</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.max_shape","title":"<code>max_shape</code>  <code>property</code>","text":"<p>Maximum required storage shape, corresponding to the shape of a cell-corner variable with maximum halo points.</p> <p>This should rarely be required, consider using appropriate calls to helper methods that get the correct shape for your particular variable.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.__init__","title":"<code>__init__(domain, n_halo, south_edge, north_edge, west_edge, east_edge)</code>","text":"<p>Initialize a grid indexing object.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Index3D</code> <p>size of the compute domain for cell-centered variables</p> required <code>n_halo</code> <code>int</code> <p>number of halo points</p> required <code>south_edge</code> <code>bool</code> <p>whether the current rank is on the south edge of a tile</p> required <code>north_edge</code> <code>bool</code> <p>whether the current rank is on the north edge of a tile</p> required <code>west_edge</code> <code>bool</code> <p>whether the current rank is on the west edge of a tile</p> required <code>east_edge</code> <code>bool</code> <p>whether the current rank is on the east edge of a tile</p> required"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.domain_compute","title":"<code>domain_compute(add=(0, 0, 0))</code>","text":"<p>Returns the shape of the compute domain, plus an optional offset.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.domain_full","title":"<code>domain_full(add=(0, 0, 0))</code>","text":"<p>Returns the shape of the full domain including halos, plus an optional offset.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.get_2d_compute_origin_domain","title":"<code>get_2d_compute_origin_domain(klevel=0)</code>","text":"<p>Get the origin and domain for a computation that occurs on the lowest klevel over a certain grid configuration (given by dims) and a certain number of halo points.</p> <p>Parameters:</p> Name Type Description Default <code>klevel</code> <code>int</code> <p>the vertical level of the domain, defaults to zero</p> <code>0</code> <p>Returns:</p> Name Type Description <code>origin</code> <code>tuple[int, ...]</code> <p>origin of the computation</p> <code>domain</code> <code>tuple[int, ...]</code> <p>shape of the computation</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.get_origin_domain","title":"<code>get_origin_domain(dims, halos=tuple())</code>","text":"<p>Get the origin and domain for a computation that occurs over a certain grid configuration (given by dims) and a certain number of halo points.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Sequence[str]</code> <p>dimension names, using dimension constants from ndsl.constants</p> required <code>halos</code> <code>Sequence[int]</code> <p>number of halo points for each dimension, defaults to zero</p> <code>tuple()</code> <p>Returns:</p> Name Type Description <code>origin</code> <code>tuple[int, ...]</code> <p>origin of the computation</p> <code>domain</code> <code>tuple[int, ...]</code> <p>shape of the computation</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.get_shape","title":"<code>get_shape(dims, halos=tuple())</code>","text":"<p>Get the storage shape required for an array with the given dimensions which is accessed up to a given number of halo points.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Sequence[str]</code> <p>dimension names, using dimension constants from ndsl.constants</p> required <code>halos</code> <code>Sequence[int]</code> <p>number of halo points for each dimension, defaults to zero</p> <code>tuple()</code> <p>Returns:</p> Name Type Description <code>origin</code> <code>int</code> <p>origin of the computation</p> <code>domain</code> <code>...</code> <p>shape of the computation</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.origin_compute","title":"<code>origin_compute(add=(0, 0, 0))</code>","text":"<p>Returns the origin of the compute domain, plus an optional offset</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.origin_full","title":"<code>origin_full(add=(0, 0, 0))</code>","text":"<p>Returns the origin of the full domain including halos, plus an optional offset.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.GridIndexing.restrict_vertical","title":"<code>restrict_vertical(k_start=0, nk=None)</code>","text":"<p>Returns a copy of itself with modified vertical origin and domain.</p> <p>Parameters:</p> Name Type Description Default <code>k_start</code> <code>int</code> <p>offset to apply to current vertical origin, must be greater than 0 and less than the size of the vertical domain</p> <code>0</code> <code>nk</code> <code>int | None</code> <p>new vertical domain size as a number of grid cells, defaults to remaining grid cells in the current domain, can be at most the size of the vertical domain minus k_start</p> <code>None</code>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.StencilFactory","title":"<code>StencilFactory</code>","text":"<p>Configurable class which creates stencil objects.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.StencilFactory.__init__","title":"<code>__init__(config, grid_indexing, comm=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>config</code> <code>StencilConfig</code> <p>gt4py-specific stencil configuration</p> required <code>grid_indexing</code> <code>GridIndexing</code> <p>configuration for domain and halo indexing</p> required <code>comm</code> <code>Comm | None</code> <p>if given, stencils will compare all data before and after stencil execution to their \"pair\" rank on the comm. This is very expensive and only used for debugging.</p> <code>None</code>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.StencilFactory.build_report","title":"<code>build_report(key='build_time', **kwargs)</code>","text":"<p>Report all stencils built by this factory.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.StencilFactory.exec_report","title":"<code>exec_report(key='total_run_time', **kwargs)</code>","text":"<p>Report all stencils executed that were built by this factory.</p>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.StencilFactory.from_dims_halo","title":"<code>from_dims_halo(func, compute_dims, compute_halos=tuple(), externals=None, skip_passes=())</code>","text":"<p>Initialize a stencil from dimensions and number of halo points.</p> <p>Automatically injects axis_offsets into stencil externals.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., None]</code> <p>stencil definition function</p> required <code>compute_dims</code> <code>Sequence[str]</code> <p>dimensionality of compute domain</p> required <code>compute_halos</code> <code>Sequence[int]</code> <p>number of halo points to include in compute domain</p> <code>tuple()</code> <code>externals</code> <code>Mapping[str, Any] | None</code> <p>compile-time external variables required by stencil</p> <code>None</code> <code>skip_passes</code> <code>tuple[str, ...]</code> <p>compiler passes to skip when building stencil</p> <code>()</code>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.StencilFactory.from_origin_domain","title":"<code>from_origin_domain(func, origin, domain, externals=None, skip_passes=())</code>","text":"<p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., None]</code> <p>stencil definition function</p> required <code>origin</code> <code>tuple[int, ...] | Mapping[str, tuple[int, ...]]</code> <p>gt4py origin to use at call time</p> required <code>domain</code> <code>tuple[int, ...]</code> <p>gt4py domain to use at call time</p> required <code>stencil_config</code> <p>container for stencil configuration</p> required <code>externals</code> <code>Mapping[str, Any] | None</code> <p>compile-time external variables required by stencil</p> <code>None</code> <code>skip_passes</code> <code>tuple[str, ...]</code> <p>compiler passes to skip when building stencil</p> <code>()</code>"},{"location":"docstrings/dsl/stencil/#dsl.stencil.TimingCollector","title":"<code>TimingCollector</code>  <code>dataclass</code>","text":"<p>Attributes:</p> Name Type Description <code>build_info</code> <code>dict[str, dict]</code> <p>contains info about the generation process for each stencil.</p> <code>exec_info</code> <code>dict[str, Any]</code> <p>contains info about the execution of each stencil.</p>"},{"location":"docstrings/dsl/stencil_config/","title":"stencil_config","text":""},{"location":"docstrings/dsl/stencil_config/#dsl.stencil_config.CompilationConfig","title":"<code>CompilationConfig</code>","text":""},{"location":"docstrings/dsl/stencil_config/#dsl.stencil_config.CompilationConfig.check_communicator","title":"<code>check_communicator(communicator)</code>","text":"<p>Checks that the communicator has a square layout</p> <p>Parameters:</p> Name Type Description Default <code>communicator</code> <code>Communicator</code> <p>communicator to use</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If non-square layout is given</p>"},{"location":"docstrings/dsl/stencil_config/#dsl.stencil_config.CompilationConfig.determine_compiling_equivalent","title":"<code>determine_compiling_equivalent(rank, partitioner)</code>","text":"<p>From my rank &amp; the current partitioner we determine which rank we should read from</p>"},{"location":"docstrings/dsl/stencil_config/#dsl.stencil_config.RunMode","title":"<code>RunMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Run-Mode for the model     Build: compile &amp; save compiled files only     BuildAndRun: compile &amp; save compiled files, then run     Run: load from .so and run, will fail if .so is not available</p>"},{"location":"docstrings/dsl/stencil_config/#dsl.stencil_config.StencilConfig","title":"<code>StencilConfig</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Hashable</code></p>"},{"location":"docstrings/dsl/typing/","title":"typing","text":""},{"location":"docstrings/dsl/typing/#dsl.typing.Field","title":"<code>Field = gtscript.Field</code>  <code>module-attribute</code>","text":"<p>A gt4py field</p>"},{"location":"docstrings/dsl/typing/#dsl.typing.global_set_precision","title":"<code>global_set_precision()</code>","text":"<p>Set the global precision for all references of Float and Int in the codebase. Defaults to 64 bit.</p>"},{"location":"docstrings/dsl/typing/#dsl.typing.is_float","title":"<code>is_float(dtype)</code>","text":"<p>Expected floating point type</p>"},{"location":"docstrings/dsl/typing/#dsl.typing.set_4d_field_size","title":"<code>set_4d_field_size(n, dtype)</code>","text":"<p>Defines a 4D field with a given size and type The extra data dimension is not parallel</p>"},{"location":"docstrings/grid/eta/","title":"eta","text":""},{"location":"docstrings/grid/eta/#grid.eta.HybridPressureCoefficients","title":"<code>HybridPressureCoefficients</code>  <code>dataclass</code>","text":"<p>Attributes:</p> Name Type Description <code>-</code> <code>ks</code> <p>The number of pure-pressure layers at the top of the model   Also the level where model transitions from pure pressure to   hybrid pressure levels</p> <code>-</code> <code>ptop</code> <p>The pressure at the top of the atmosphere</p> <code>-</code> <code>ak</code> <p>The additive coefficient in the pressure calculation</p> <code>-</code> <code>bk</code> <p>The multiplicative coefficient in the pressure calculation</p>"},{"location":"docstrings/grid/eta/#grid.eta.compute_eta","title":"<code>compute_eta(ak, bk)</code>","text":"<p>Equation (1) JRMS2006 eta is the vertical coordinate and eta_v is an auxiliary vertical coordinate</p>"},{"location":"docstrings/grid/eta/#grid.eta.set_hybrid_pressure_coefficients","title":"<code>set_hybrid_pressure_coefficients(km, eta_file=None, ak_data=None, bk_data=None)</code>","text":"<p>Sets the coefficients describing the hybrid pressure coordinates.</p> <p>The pressure of each k-level is calculated as Pk = ak + (bk * Ps) where Ps is the surface pressure. Values are currently stored in lookup tables.</p> <p>Parameters:</p> Name Type Description Default <code>km</code> <code>int</code> <p>The number of vertical levels in the model</p> required <p>Returns:</p> Type Description <code>HybridPressureCoefficients</code> <p>a HybridPressureCoefficients dataclass</p>"},{"location":"docstrings/grid/eta/#grid.eta.vertical_coordinate","title":"<code>vertical_coordinate(eta_value)</code>","text":"<p>Equation (1) JRMS2006 computes eta_v, the auxiliary variable vertical coordinate</p>"},{"location":"docstrings/grid/generation/","title":"generation","text":""},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms","title":"<code>MetricTerms</code>","text":""},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.a11","title":"<code>a11</code>  <code>property</code>","text":"<p>0.5*z22/sin_sg5</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.a12","title":"<code>a12</code>  <code>property</code>","text":"<p>0.5*z21/sin_sg5</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.a21","title":"<code>a21</code>  <code>property</code>","text":"<p>0.5*z12/sin_sg5</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.a22","title":"<code>a22</code>  <code>property</code>","text":"<p>0.5*z11/sin_sg5</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.agrid_lon_lat","title":"<code>agrid_lon_lat</code>  <code>property</code>","text":"<p>The longitudes and latitudes of the cell centers.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.ak","title":"<code>ak</code>  <code>property</code>","text":"<p>The ak coefficient used to calculate the pressure at a given k-level:</p> <p>pk = ak + (bk * ps)</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.area","title":"<code>area</code>  <code>property</code>","text":"<p>The area of each a-grid cell.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.area64","title":"<code>area64</code>  <code>property</code>","text":"<p>The area of each a-grid cell, at 64-bit precision.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.area_c","title":"<code>area_c</code>  <code>property</code>","text":"<p>The area of each c-grid cell.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.bk","title":"<code>bk</code>  <code>property</code>","text":"<p>The bk coefficient used to calculate the pressure at a given k-level:</p> <p>pk = ak + (bk * ps)</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cos_sg1","title":"<code>cos_sg1</code>  <code>property</code>","text":"<p>Cosine of the angle at point 1 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cos_sg2","title":"<code>cos_sg2</code>  <code>property</code>","text":"<p>Cosine of the angle at point 2 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cos_sg3","title":"<code>cos_sg3</code>  <code>property</code>","text":"<p>Cosine of the angle at point 3 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cos_sg4","title":"<code>cos_sg4</code>  <code>property</code>","text":"<p>Cosine of the angle at point 4 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cos_sg5","title":"<code>cos_sg5</code>  <code>property</code>","text":"<p>Cosine of the angle at point 5 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7 The inner product of ec1 and ec2 for point 5</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cos_sg6","title":"<code>cos_sg6</code>  <code>property</code>","text":"<p>Cosine of the angle at point 6 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cos_sg7","title":"<code>cos_sg7</code>  <code>property</code>","text":"<p>Cosine of the angle at point 7 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cos_sg8","title":"<code>cos_sg8</code>  <code>property</code>","text":"<p>Cosine of the angle at point 8 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cos_sg9","title":"<code>cos_sg9</code>  <code>property</code>","text":"<p>Cosine of the angle at point 9 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cosa","title":"<code>cosa</code>  <code>property</code>","text":"<p>Cosine of angle between coordinate lines at the cell corners.</p> <p>Averaged to ensure consistent answers.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cosa_s","title":"<code>cosa_s</code>  <code>property</code>","text":"<p>as cosa but defined at cell centers</p> <p>Averaged to ensure consistent answers.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cosa_u","title":"<code>cosa_u</code>  <code>property</code>","text":"<p>Cosine of angle between coordinate lines at the left and right cell edges.</p> <p>Averaged to ensure consistent answers.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.cosa_v","title":"<code>cosa_v</code>  <code>property</code>","text":"<p>Cosine of angle between coordinate lines at the top and bottom cell edges.</p> <p>Averaged to ensure consistent answers.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.da_max","title":"<code>da_max</code>  <code>property</code>","text":"<p>Fhe maximum agrid cell area across all ranks.</p> <p>Ff mpi is not present and the communicator is a DummyComm this will be the maximum on the local rank.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.da_max_c","title":"<code>da_max_c</code>  <code>property</code>","text":"<p>The maximum cgrid cell area across all ranks.</p> <p>If mpi is not present and the communicator is a DummyComm this will be the maximum on the local rank.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.da_min","title":"<code>da_min</code>  <code>property</code>","text":"<p>The minimum agrid cell area across all ranks.</p> <p>If mpi is not present and the communicator is a DummyComm this will be the minimum on the local rank.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.da_min_c","title":"<code>da_min_c</code>  <code>property</code>","text":"<p>The minimum cgrid cell area across all ranks.</p> <p>If mpi is not present and the communicator is a DummyComm this will be the minimum on the local rank.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.del6_u","title":"<code>del6_u</code>  <code>property</code>","text":"<p>sina_v * dx/dyc</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.del6_v","title":"<code>del6_v</code>  <code>property</code>","text":"<p>sina_u * dy/dxc</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.dgrid_lon_lat","title":"<code>dgrid_lon_lat</code>  <code>property</code>","text":"<p>The longitudes and latitudes of the cell corners.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.divg_u","title":"<code>divg_u</code>  <code>property</code>","text":"<p>sina_v * dyc/dx</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.divg_v","title":"<code>divg_v</code>  <code>property</code>","text":"<p>sina_u * dxc/dy</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.dx","title":"<code>dx</code>  <code>property</code>","text":"<p>The distance between grid corners along the x-direction.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.dxa","title":"<code>dxa</code>  <code>property</code>","text":"<p>The with of each grid cell along the x-direction.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.dxc","title":"<code>dxc</code>  <code>property</code>","text":"<p>The distance between cell centers along the x-direction.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.dy","title":"<code>dy</code>  <code>property</code>","text":"<p>The distance between grid corners along the y-direction.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.dya","title":"<code>dya</code>  <code>property</code>","text":"<p>The with of each grid cell along the y-direction.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.dyc","title":"<code>dyc</code>  <code>property</code>","text":"<p>The distance between cell centers along the y-direction.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.ec1","title":"<code>ec1</code>  <code>property</code>","text":"<p>Cartesian components of the local unit vector in the x-direction at the cell centers.</p> <p>3d array whose last dimension is length 3 and indicates cartesian x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.ec2","title":"<code>ec2</code>  <code>property</code>","text":"<p>Cartesian components of the local unit vector in the y-direction at the cell centers.</p> <p>3d array whose last dimension is length 3 and indicates cartesian x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_e","title":"<code>edge_e</code>  <code>property</code>","text":"<p>Factor to interpolate scalars from a to c grid at the eastern grid edge.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_n","title":"<code>edge_n</code>  <code>property</code>","text":"<p>Factor to interpolate scalars from a to c grid at the northern grid edge.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_s","title":"<code>edge_s</code>  <code>property</code>","text":"<p>Factor to interpolate scalars from a to c grid at the southern grid edge.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_vect_e","title":"<code>edge_vect_e</code>  <code>property</code>","text":"<p>Factor to interpolate vectors from a to c grid at the eastern grid edge repeated in x and y to be used in stencils.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_vect_e_1d","title":"<code>edge_vect_e_1d</code>  <code>property</code>","text":"<p>Factor to interpolate vectors from a to c grid at the eastern grid edge.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_vect_n","title":"<code>edge_vect_n</code>  <code>property</code>","text":"<p>Factor to interpolate vectors from a to c grid at the northern grid edge.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_vect_s","title":"<code>edge_vect_s</code>  <code>property</code>","text":"<p>Factor to interpolate vectors from a to c grid at the southern grid edge.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_vect_w","title":"<code>edge_vect_w</code>  <code>property</code>","text":"<p>Factor to interpolate vectors from a to c grid at the western grid edge repeated in x and y to be used in stencils.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_vect_w_1d","title":"<code>edge_vect_w_1d</code>  <code>property</code>","text":"<p>Factor to interpolate vectors from a to c grid at the western grid edge.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.edge_w","title":"<code>edge_w</code>  <code>property</code>","text":"<p>Factor to interpolate scalars from a to c grid at the western grid edge.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.ee1","title":"<code>ee1</code>  <code>property</code>","text":"<p>Cartesian components of the local unit vetcor in the x-direation at the cell corners.</p> <p>3d array whose last dimension is length 3 and indicates cartesian x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.ee2","title":"<code>ee2</code>  <code>property</code>","text":"<p>Cartesian components of the local unit vetcor in the y-direation at the cell corners.</p> <p>3d array whose last dimension is length 3 and indicates cartesian x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.es1","title":"<code>es1</code>  <code>property</code>","text":"<p>Cartesian components of the local unit vetcor in the x-direation at the top/bottom cell edges.</p> <p>3d array whose last dimension is length 3 and indicates cartesian x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.es2","title":"<code>es2</code>  <code>property</code>","text":"<p>Cartesian components of the local unit vetcor in the y-direation at the top/bottom cell edges.</p> <p>3d array whose last dimension is length 3 and indicates cartesian x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.ew1","title":"<code>ew1</code>  <code>property</code>","text":"<p>Cartesian components of the local unit vector in the x-direction at the left/right cell edges.</p> <p>3d array whose last dimension is length 3 and indicates cartesian x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.ew2","title":"<code>ew2</code>  <code>property</code>","text":"<p>Cartesian components of the local unit vector in the y-direction at the left/right cell edges.</p> <p>3d array whose last dimension is length 3 and indicates cartesian x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.ks","title":"<code>ks</code>  <code>property</code>","text":"<p>Number of levels where the vertical coordinate is purely pressure-based.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.l2c_u","title":"<code>l2c_u</code>  <code>property</code>","text":"<p>Angular momentum correction for converting u-winds from lat/lon to cartesian coordinates.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.l2c_v","title":"<code>l2c_v</code>  <code>property</code>","text":"<p>Angular momentum correction for converting v-winds from lat/lon to cartesian coordinates.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.ptop","title":"<code>ptop</code>  <code>property</code>","text":"<p>The pressure of the top of atmosphere level.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rarea","title":"<code>rarea</code>  <code>cached</code> <code>property</code>","text":"<p>1/cell area</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rarea_c","title":"<code>rarea_c</code>  <code>cached</code> <code>property</code>","text":"<p>1/cgrid cell area</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rdx","title":"<code>rdx</code>  <code>cached</code> <code>property</code>","text":"<p>1/dx</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rdxa","title":"<code>rdxa</code>  <code>cached</code> <code>property</code>","text":"<p>1/dxa</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rdxc","title":"<code>rdxc</code>  <code>cached</code> <code>property</code>","text":"<p>1/dxc</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rdy","title":"<code>rdy</code>  <code>cached</code> <code>property</code>","text":"<p>1/dy</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rdya","title":"<code>rdya</code>  <code>cached</code> <code>property</code>","text":"<p>1/dya</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rdyc","title":"<code>rdyc</code>  <code>cached</code> <code>property</code>","text":"<p>1/dyc</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rsin2","title":"<code>rsin2</code>  <code>property</code>","text":"<p>1/sin_sg5**2, defined as the inverse-squrared as it is only used as such</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rsin_u","title":"<code>rsin_u</code>  <code>property</code>","text":"<p>1/sina_u**2, defined as the inverse-squrared as it is only used as such</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rsin_v","title":"<code>rsin_v</code>  <code>property</code>","text":"<p>1/sina_v**2, defined as the inverse-squrared as it is only used as such</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.rsina","title":"<code>rsina</code>  <code>property</code>","text":"<p>1/sina**2, defined as the inverse-squrared as it is only used as such</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sin_sg1","title":"<code>sin_sg1</code>  <code>property</code>","text":"<p>Sine of the angle at point 1 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sin_sg2","title":"<code>sin_sg2</code>  <code>property</code>","text":"<p>Sine of the angle at point 2 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sin_sg3","title":"<code>sin_sg3</code>  <code>property</code>","text":"<p>Sine of the angle at point 3 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sin_sg4","title":"<code>sin_sg4</code>  <code>property</code>","text":"<p>Sine of the angle at point 4 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sin_sg5","title":"<code>sin_sg5</code>  <code>property</code>","text":"<p>Sine of the angle at point 5 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p> <p>For the center point this is one minus the inner product of ec1 and ec2 squared</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sin_sg6","title":"<code>sin_sg6</code>  <code>property</code>","text":"<p>Sine of the angle at point 6 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sin_sg7","title":"<code>sin_sg7</code>  <code>property</code>","text":"<p>Sine of the angle at point 7 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sin_sg8","title":"<code>sin_sg8</code>  <code>property</code>","text":"<p>Sine of the angle at point 8 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sin_sg9","title":"<code>sin_sg9</code>  <code>property</code>","text":"<p>Sine of the angle at point 9 of the 'supergrid' within each grid cell:</p> <p>9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sina","title":"<code>sina</code>  <code>property</code>","text":"<p>Sine of angle between coordinate lines at the cell corners.</p> <p>Averaged to ensure consistent answers.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sina_u","title":"<code>sina_u</code>  <code>property</code>","text":"<p>Sine of angle between coordinate lines at the left and right cell edges.</p> <p>Averaged to ensure consistent answers.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.sina_v","title":"<code>sina_v</code>  <code>property</code>","text":"<p>Sine of angle between coordinate lines at the top and bottom cell edges.</p> <p>Averaged to ensure consistent answers.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.vlat","title":"<code>vlat</code>  <code>property</code>","text":"<p>Unit vector in northward latitude direction.</p> <p>3d array whose last dimension is length 3 and indicates x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.vlon","title":"<code>vlon</code>  <code>property</code>","text":"<p>Unit vector in eastward longitude direction.</p> <p>3d array whose last dimension is length 3 and indicates x/y/z value.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.z11","title":"<code>z11</code>  <code>property</code>","text":"<p>Vector product of horizontal component of the cell-center vector with the unit longitude vector.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.z12","title":"<code>z12</code>  <code>property</code>","text":"<p>Vector product of horizontal component of the cell-center vector with the unit latitude vector.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.z21","title":"<code>z21</code>  <code>property</code>","text":"<p>Vector product of vertical component of the cell-center vector with the unit longitude vector.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.z22","title":"<code>z22</code>  <code>property</code>","text":"<p>Vector product of vertical component of the cell-center vector with the unit latitude vector.</p>"},{"location":"docstrings/grid/generation/#grid.generation.MetricTerms.from_external","title":"<code>from_external(x, y, quantity_factory, communicator, grid_type, eta_file=None)</code>  <code>classmethod</code>","text":"<p>Generates a metric terms object, using input from data contained in an externally generated tile file.</p>"},{"location":"docstrings/grid/generation/#grid.generation.quantity_cast_to_model_float","title":"<code>quantity_cast_to_model_float(quantity_factory, qty_64)</code>","text":"<p>Copy &amp; cast from 64-bit float to model precision if need be.</p>"},{"location":"docstrings/grid/geometry/","title":"geometry","text":""},{"location":"docstrings/grid/geometry/#grid.geometry.calc_unit_vector_south","title":"<code>calc_unit_vector_south(xyz_dgrid, xyz_agrid, grid_type, nhalo, tile_partitioner, rank, np)</code>","text":"<p>Calculates the cartesian unit vectors at the top/bottom edges of each grid cell.</p> <p>Returns:</p> Name Type Description <code>vector1</code> <p>the horizontal unit vector</p> <code>vector2</code> <p>the vertical unit vector</p>"},{"location":"docstrings/grid/geometry/#grid.geometry.calc_unit_vector_west","title":"<code>calc_unit_vector_west(xyz_dgrid, xyz_agrid, grid_type, nhalo, tile_partitioner, rank, np)</code>","text":"<p>Calculates the cartesian unit vectors at the left/right edges of each grid cell.</p> <p>Returns:</p> Name Type Description <code>vector1</code> <p>the horizontal unit vector</p> <code>vector2</code> <p>the vertical unit vector</p>"},{"location":"docstrings/grid/geometry/#grid.geometry.calculate_supergrid_cos_sin","title":"<code>calculate_supergrid_cos_sin(xyz_dgrid, xyz_agrid, ec1, ec2, grid_type, nhalo, tile_partitioner, rank, np)</code>","text":"<p>Calculates the cosine and sine of the grid angles at each of the following points in a supergrid cell: 9---4---8 |       | 1   5   3 |       | 6---2---7</p>"},{"location":"docstrings/grid/geometry/#grid.geometry.calculate_trig_uv","title":"<code>calculate_trig_uv(xyz_dgrid, cos_sg, sin_sg, nhalo, tile_partitioner, rank, np)</code>","text":"<p>Calculates more trig quantities</p>"},{"location":"docstrings/grid/geometry/#grid.geometry.calculate_xy_unit_vectors","title":"<code>calculate_xy_unit_vectors(xyz_dgrid, nhalo, tile_partitioner, rank, np)</code>","text":"<p>Calculates the cartesian unit vectors at the corners of each grid cell. vector1 is the horizontal unit vector, while vector2 is the vertical unit vector</p>"},{"location":"docstrings/grid/geometry/#grid.geometry.edge_factors","title":"<code>edge_factors(grid_quantity, agrid, grid_type, nhalo, tile_partitioner, rank, radius, np)</code>","text":"<p>Creates interpolation factors from the A grid to the B grid on tile edges</p>"},{"location":"docstrings/grid/geometry/#grid.geometry.efactor_a2c_v","title":"<code>efactor_a2c_v(grid_quantity, agrid, grid_type, nhalo, tile_partitioner, rank, radius, np)</code>","text":"<p>Creates interpolation factors at tile edges for interpolating vectors from A to C grids</p>"},{"location":"docstrings/grid/geometry/#grid.geometry.get_center_vector","title":"<code>get_center_vector(xyz_gridpoints, grid_type, nhalo, tile_partitioner, rank, np)</code>","text":"<p>Calculates the cartesian unit vectors at the center of each grid cell.</p> <p>Returns:</p> Name Type Description <code>vector1</code> <p>the horizontal unit vector</p> <code>vector2</code> <p>the vertical unit vector</p>"},{"location":"docstrings/grid/geometry/#grid.geometry.supergrid_corner_fix","title":"<code>supergrid_corner_fix(cos_sg, sin_sg, nhalo, tile_partitioner, rank)</code>","text":"<p>filling the ghost cells overwrites some of the sin_sg values along the outward-facing edge of a tile in the corners, which is incorrect. This function resolves the issue by filling in the appropriate values after the _fill_single_halo_corner call</p>"},{"location":"docstrings/grid/geometry/#grid.geometry.unit_vector_lonlat","title":"<code>unit_vector_lonlat(grid, np)</code>","text":"<p>Calculates the cartesian unit vectors for each point on a lat/lon grid</p>"},{"location":"docstrings/grid/global_setup/","title":"global_setup","text":""},{"location":"docstrings/grid/global_setup/#grid.global_setup.global_mirror_grid","title":"<code>global_mirror_grid(grid_global, ng, npx, npy, np, right_hand_grid)</code>","text":"<p>Mirrors and rotates all tiles of a lon/lat grid to the correct orientation. The tiles must then be partitioned onto the appropriate ranks. This global mesh generation is the way the Fortran code initializes the lon/lat grids and is reproduced here for testing purposes.</p>"},{"location":"docstrings/grid/global_setup/#grid.global_setup.gnomonic_grid","title":"<code>gnomonic_grid(grid_type, lon, lat, np)</code>","text":"<p>Apply gnomonic grid to lon and lat arrays for all tiles. Tiles must then be rotated and mirrored to the correct orientations before use. This global mesh generation is the way the Fortran code initializes the lon/lat grids and is reproduced here for testing purposes.</p> <p>Parameters:</p> Name Type Description Default <code>grid_type</code> <code>int</code> <p>type of grid to apply</p> required <code>lon</code> <p>longitude array with dimensions [x, y]</p> required <code>lat</code> <p>latitude array with dimensions [x, y]</p> required"},{"location":"docstrings/grid/gnomonic/","title":"gnomonic","text":""},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.fortran_vector_spherical_angle","title":"<code>fortran_vector_spherical_angle(e1, e2, e3)</code>","text":"<p>The Fortran version     Given x/y/z tuples, compute the spherical angle between     them according to: !           p3 !         / !        / !       p_center ---&gt; angle !         !          !           p2     This angle will always be less than Pi.</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.get_area","title":"<code>get_area(lon, lat, radius, np)</code>","text":"<p>Given latitude and longitude on cell corners, return the area of each cell.</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.get_lonlat_vect","title":"<code>get_lonlat_vect(lonlat_grid, np)</code>","text":"<p>Calculates the unit vectors pointing in the longitude/latitude directions for a set of longitude/latitude points</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.get_rectangle_area","title":"<code>get_rectangle_area(p1, p2, p3, p4, radius, np)</code>","text":"<p>Given four point arrays whose last dimensions are x/y/z in clockwise or counterclockwise order, return an array of spherical rectangle areas. NOTE, this is not the exact same order of operations as the Fortran code This results in some errors in the last digit, but the spherical_angle is an exact match. The errors in the last digit multiplied out by the radius end up causing relative errors larger than 1e-14, but still within 1e-12.</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.get_triangle_area","title":"<code>get_triangle_area(p1, p2, p3, radius, np)</code>","text":"<p>Given three point arrays whose last dimensions are x/y/z, return an array of spherical triangle areas.</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.get_unit_vector_direction","title":"<code>get_unit_vector_direction(p1, p2, np)</code>","text":"<p>Returns the unit vector pointing from a set of lonlat points p1 to lonlat points p2</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.great_circle_distance_along_axis","title":"<code>great_circle_distance_along_axis(lon, lat, radius, np, axis=0)</code>","text":"<p>Returns the great-circle distance between points along the desired axis.</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.lon_lat_to_xyz","title":"<code>lon_lat_to_xyz(lon, lat, np)</code>","text":"<p>map (lon, lat) to (x, y, z) Args:     lon: 2d array of longitudes     lat: 2d array of latitudes     np: numpy-like module for arrays Returns:     xyz: 3d array whose last dimension is length 3 and indicates x/y/z value</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.set_c_grid_tile_border_area","title":"<code>set_c_grid_tile_border_area(xyz_dgrid, xyz_agrid, radius, area_cgrid, tile_partitioner, rank, np)</code>","text":"<p>Using latitude and longitude without halo points, fix C-grid area at tile edges and corners. Naively, the c-grid area is calculated as the area between the rectangle at the four corners of the grid cell. At tile edges however, this is not accurate, because the area makes a butterfly-like shape as it crosses the tile boundary. Instead we calculate the area on one side of that shape, and multiply it by two. At corners, the corner is composed of three rectangles from each tile bordering the corner. We calculate the area from one tile and multiply it by three. Args:     xyz_dgrid: d-grid cartesian coordinates as a 3-d array, last dimension         of length 3 indicating x/y/z     xyz_agrid: a-grid cartesian coordinates as a 3-d array, last dimension         of length 3 indicating x/y/z     area_cgrid: 2d array of c-grid areas     radius: radius of Earth in metres     tile_partitioner: partitioner class to determine subtile position     rank: rank of current tile     np: numpy-like module to interact with arrays</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.set_corner_area_to_triangle_area","title":"<code>set_corner_area_to_triangle_area(lon, lat, area, tile_partitioner, rank, radius, np)</code>","text":"<p>Given latitude and longitude on cell corners, and an array of cell areas, set the four corner areas to the area of the inner triangle at those corners.</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.spherical_angle","title":"<code>spherical_angle(p_center, p2, p3, np)</code>","text":"<pre><code>Given ndarrays whose last dimension is x/y/z, compute the spherical angle between\nthem according to:\n</code></pre> <p>!           p3 !         / !        / !       p_center ---&gt; angle !         !          !           p2     This angle will always be less than Pi.</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.spherical_cos","title":"<code>spherical_cos(p_center, p2, p3, np)</code>","text":"<p>As Spherical angle, but returns cos(angle)</p>"},{"location":"docstrings/grid/gnomonic/#grid.gnomonic.xyz_to_lon_lat","title":"<code>xyz_to_lon_lat(xyz, np)</code>","text":"<p>map (x, y, z) to (lon, lat) Returns:     xyz: 3d array whose last dimension is length 3 and indicates x/y/z value     np: numpy-like module for arrays Returns:     lon: 2d array of longitudes     lat: 2d array of latitudes</p>"},{"location":"docstrings/grid/helper/","title":"helper","text":""},{"location":"docstrings/grid/helper/#grid.helper.AngleGridData","title":"<code>AngleGridData</code>  <code>dataclass</code>","text":"<p>sin and cos of certain angles used in metric calculations.</p> <p>Corresponds in the fortran code to sin_sg and cos_sg.</p>"},{"location":"docstrings/grid/helper/#grid.helper.ContravariantGridData","title":"<code>ContravariantGridData</code>  <code>dataclass</code>","text":"<p>Grid variables used for converting vectors from covariant to contravariant components.</p>"},{"location":"docstrings/grid/helper/#grid.helper.DampingCoefficients","title":"<code>DampingCoefficients</code>  <code>dataclass</code>","text":"<p>Terms used to compute damping coefficients.</p>"},{"location":"docstrings/grid/helper/#grid.helper.DriverGridData","title":"<code>DriverGridData</code>  <code>dataclass</code>","text":"<p>Terms used to Apply Physics changes to the Dycore. Attributes:   vlon1: x-component of unit lon vector in eastward longitude direction   vlon2: y-component of unit lon vector in eastward longitude direction   vlon3: z-component of unit lon vector in eastward longitude direction   vlat1: x-component of unit lat vector in northward latitude direction   vlat2: y-component of unit lat vector in northward latitude direction   vlat3: z-component of unit lat vector in northward latitude direction   edge_vect_w: factor to interpolate A to C grids at the western grid edge   edge_vect_e: factor to interpolate A to C grids at the easter grid edge   edge_vect_s: factor to interpolate A to C grids at the southern grid edge   edge_vect_n: factor to interpolate A to C grids at the northern grid edge   es1_1: x-component of grid local unit vector in x-direction at cell edge   es1_2: y-component of grid local unit vector in x-direction at cell edge   es1_3: z-component of grid local unit vector in x-direction at cell edge   ew2_1: x-component of grid local unit vector in y-direction at cell edge   ew2_2: y-component of grid local unit vector in y-direction at cell edge   ew2_3: z-component of grid local unit vector in y-direction at cell edge</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData","title":"<code>GridData</code>","text":""},{"location":"docstrings/grid/helper/#grid.helper.GridData.ak","title":"<code>ak</code>  <code>property</code> <code>writable</code>","text":"<p>constant used to define pressure at vertical interfaces, where p = ak + bk * p_ref</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.area","title":"<code>area</code>  <code>property</code>","text":"<p>Gridcell area</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.area_64","title":"<code>area_64</code>  <code>property</code>","text":"<p>Gridcell area (64-bit)</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.bk","title":"<code>bk</code>  <code>property</code> <code>writable</code>","text":"<p>constant used to define pressure at vertical interfaces, where p = ak + bk * p_ref</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.dx","title":"<code>dx</code>  <code>property</code>","text":"<p>distance between cell corners in x-direction</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.dxa","title":"<code>dxa</code>  <code>property</code>","text":"<p>distance between centers of west and east edges of gridcell</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.dxc","title":"<code>dxc</code>  <code>property</code>","text":"<p>distance between gridcell centers in x-direction</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.dy","title":"<code>dy</code>  <code>property</code>","text":"<p>distance between cell corners in y-direction</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.dya","title":"<code>dya</code>  <code>property</code>","text":"<p>distance between centers of north and south edges of gridcell</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.dyc","title":"<code>dyc</code>  <code>property</code>","text":"<p>distance between gridcell centers in y-direction</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.fC","title":"<code>fC</code>  <code>property</code>","text":"<p>Coriolis parameter at cell corners</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.fC_agrid","title":"<code>fC_agrid</code>  <code>property</code>","text":"<p>Coriolis parameter at cell centers</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.lat","title":"<code>lat</code>  <code>property</code>","text":"<p>latitude of cell corners</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.lat_agrid","title":"<code>lat_agrid</code>  <code>property</code>","text":"<p>latitude on the A-grid (cell centers)</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.lon","title":"<code>lon</code>  <code>property</code>","text":"<p>longitude of cell corners</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.lon_agrid","title":"<code>lon_agrid</code>  <code>property</code>","text":"<p>longitude on the A-grid (cell centers)</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.p","title":"<code>p</code>  <code>property</code>","text":"<p>Reference pressure profile for Eulerian grid, defined at cell centers.</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.p_ref","title":"<code>p_ref</code>  <code>property</code>","text":"<p>reference pressure (Pa) used to define pressure at vertical interfaces, where p = ak + bk * p_ref</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.ptop","title":"<code>ptop</code>  <code>property</code> <code>writable</code>","text":"<p>pressure at top of atmosphere (Pa)</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.rarea","title":"<code>rarea</code>  <code>property</code>","text":"<p>1 / area</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.rdx","title":"<code>rdx</code>  <code>property</code>","text":"<p>1 / dx</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.rdxa","title":"<code>rdxa</code>  <code>property</code>","text":"<p>1 / dxa</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.rdxc","title":"<code>rdxc</code>  <code>property</code>","text":"<p>1 / dxc</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.rdy","title":"<code>rdy</code>  <code>property</code>","text":"<p>1 / dy</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.rdya","title":"<code>rdya</code>  <code>property</code>","text":"<p>1 / dya</p>"},{"location":"docstrings/grid/helper/#grid.helper.GridData.rdyc","title":"<code>rdyc</code>  <code>property</code>","text":"<p>1 / dyc</p>"},{"location":"docstrings/grid/helper/#grid.helper.HorizontalGridData","title":"<code>HorizontalGridData</code>  <code>dataclass</code>","text":"<p>Terms defining the horizontal grid.</p>"},{"location":"docstrings/grid/helper/#grid.helper.VerticalGridData","title":"<code>VerticalGridData</code>  <code>dataclass</code>","text":"<p>Terms defining the vertical grid.</p> <p>Eulerian vertical grid is defined by p = ak + bk * p_ref.</p>"},{"location":"docstrings/grid/helper/#grid.helper.VerticalGridData.bk","title":"<code>bk</code>  <code>instance-attribute</code>","text":"<p>Reference pressure (Pa) used to define pressure at vertical interfaces, where p = ak + bk * p_ref.</p>"},{"location":"docstrings/grid/helper/#grid.helper.VerticalGridData.p_ref","title":"<code>p_ref</code>  <code>property</code>","text":"<p>Reference pressure (Pa)</p>"},{"location":"docstrings/grid/helper/#grid.helper.VerticalGridData.ptop","title":"<code>ptop</code>  <code>property</code>","text":"<p>Top of atmosphere pressure (Pa)</p>"},{"location":"docstrings/grid/helper/#grid.helper.split_quantity_along_last_dim","title":"<code>split_quantity_along_last_dim(quantity)</code>","text":"<p>Split a quantity along the last dimension into a list of quantities.</p> <p>Parameters:</p> Name Type Description Default <code>quantity</code> <code>Quantity</code> <p>Quantity to split.</p> required <p>Returns:</p> Type Description <code>list[Quantity]</code> <p>list[Quantity]: List of quantities.</p>"},{"location":"docstrings/grid/mirror/","title":"mirror","text":""},{"location":"docstrings/grid/stretch_transformation/","title":"stretch_transformation","text":""},{"location":"docstrings/grid/stretch_transformation/#grid.stretch_transformation.direct_transform","title":"<code>direct_transform(*, lon, lat, stretch_factor, lon_target, lat_target, np)</code>","text":"<p>The direct_transform subroutine from fv_grid_utils.F90. Takes in latitude and longitude in radians. Shrinks tile 6 by stretch factor in area to increase resolution locally. Then performs translation of all tiles so that the now-smaller tile 6 is centered on lon_target, lat_target.</p> <p>Parameters:</p> Name Type Description Default <code>np</code> <p>numpy or cupy module</p> required <p>Returns:</p> Type Description <code>T</code> <p>lon_transform (out) in radians</p> <code>T</code> <p>lat_transform (out) in radians</p>"},{"location":"docstrings/halo/cuda_kernels/","title":"cuda_kernels","text":""},{"location":"docstrings/halo/cuda_kernels/#halo.cuda_kernels.pack_scalar_code","title":"<code>pack_scalar_code(float_dtype)</code>","text":"<p>Pack into o_destinationBuffer data from i_sourceArray.</p> <p>The indexation into i_sourceArray is stored in i_indexes. i_offset is the offset in the destination buffer. i_nIndex allows to protect from out-of-bound read in kernel.</p> <p>tid is the global unique index calculated from the CUDA scheduler inner data.</p>"},{"location":"docstrings/halo/cuda_kernels/#halo.cuda_kernels.pack_vector_code","title":"<code>pack_vector_code(float_dtype)</code>","text":"<p>Pack into o_destinationBuffer data from i_sourceArrayX/Y.</p> <p>The indexation into i_sourceArrayX/Y is stored in i_indexesX/Y. i_offset is the offset in the destination buffer. i_nIndexX/Y allows to protect from out-of-bound read in kernel. i_rotate refers to the rotation that needs to be applied prior to assignment.</p> <p>tid is the global unique index calculated from the CUDA scheduler inner data.</p>"},{"location":"docstrings/halo/cuda_kernels/#halo.cuda_kernels.unpack_scalar_code","title":"<code>unpack_scalar_code(float_dtype)</code>","text":"<p>Unpack into o_destinationArray data from i_sourceBuffer.</p> <p>The indexation into o_destinationArray is stored in i_indexes. i_offset is the offset in the source buffer. i_nIndex allows to protect from out-of-bound read in kernel.</p> <p>tid is the global unique index calculated from the CUDA scheduler inner data.</p>"},{"location":"docstrings/halo/cuda_kernels/#halo.cuda_kernels.unpack_vector_code","title":"<code>unpack_vector_code(float_dtype)</code>","text":"<p>Unpack into o_destinationArrayX/Y data from i_sourceBuffer.</p> <p>The indexation into o_destinationArrayX/Y is stored in i_indexesX/Y. i_offset is the offset in the source buffer. i_nIndexX/Y allows to protect from out-of-bound read in kernel.</p> <p>tid is the global unique index calculated from the CUDA scheduler inner data.</p>"},{"location":"docstrings/halo/data_transformer/","title":"data_transformer","text":""},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer","title":"<code>HaloDataTransformer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Transform data to exchange in a format optimized for network communication.</p> <p>Current strategy: pack/unpack multiple nD array into/from a single buffer. Offers a pack and an unpack buffer to use for communicating data.</p> <p>The class is responsible for packing &amp; unpacking, not communication. Order of operations: - get HaloDataTransformer via get() with N transformation   with the proper halo specifications.   At the end of get() a _compile() will be triggered, reading   the internal buffers. - call async_pack(quantities) to start packing the quantities in the   internal buffer. - synchronize() to make sure all operations are finished or use get_pack_buffer()   when ready to communicate which will internally call synchronize. [... user should communicate the buffers...] - call async_unpack(quantities) to start unpacking - call synchronize() to finish all the unpacking operations and make sure   the quantities passed in async_unpack have been updated.</p> <p>The class will hold onto the buffers up until deletion, where they will be returned to an internal buffer pool.</p>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer.__init__","title":"<code>__init__(np_module, exchange_descriptors_x, exchange_descriptors_y=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>np_module</code> <code>NumpyModule</code> <p>numpy-like module for allocation</p> required <code>exchange_descriptors_x</code> <code>Sequence[HaloExchangeSpec]</code> <p>list of memory information describing an exchange. Used for scalar data and the x-component of vectors.</p> required <code>exchange_descriptors_y</code> <code>Sequence[HaloExchangeSpec] | None</code> <p>list of memory information describing an exchange. Optional, used for the y-component of vectors only. If <code>none</code> the data will packed as a scalar.</p> <code>None</code>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer.async_pack","title":"<code>async_pack(quantities_x, quantities_y=None)</code>  <code>abstractmethod</code>","text":"<p>Pack all given quantities into a single send Buffer.</p> <p>Does not guarantee the buffer returned by <code>get_unpack_buffer</code> has received data, doing so requires calling <code>synchronize</code>. Reaching for the buffer via get_pack_buffer() will call synchronize().</p> <p>Parameters:</p> Name Type Description Default <code>quantities_x</code> <code>list[Quantity]</code> <p>scalar or vector x-component quantities to pack, if one is vector they must all be vector</p> required <code>quantities_y</code> <code>list[Quantity] | None</code> <p>if quantities are vector, the y-component quantities.</p> <code>None</code>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer.async_unpack","title":"<code>async_unpack(quantities_x, quantities_y=None)</code>  <code>abstractmethod</code>","text":"<p>Unpack the buffer into destination quantities.</p> <p>Does not guarantee the buffer returned by <code>get_unpack_buffer</code> has received data, doing so requires calling <code>synchronize</code>. Reaching for the buffer via get_unpack_buffer() will call synchronize().</p> <p>Parameters:</p> Name Type Description Default <code>quantities_x</code> <code>list[Quantity]</code> <p>scalar or vector x-component quantities to be unpacked into, if one is vector they must all be vector</p> required <code>quantities_y</code> <code>list[Quantity] | None</code> <p>if quantities are vector, the y-component quantities.</p> <code>None</code>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer.finalize","title":"<code>finalize()</code>","text":"<p>Deletion routine, making sure all buffers were inserted back into cache.</p>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer.get","title":"<code>get(np_module, exchange_descriptors_x, exchange_descriptors_y=None)</code>  <code>staticmethod</code>","text":"<p>Construct a module from a numpy-like module.</p> <p>Parameters:</p> Name Type Description Default <code>np_module</code> <code>NumpyModule</code> <p>numpy-like module to determine child transformer type.</p> required <code>exchange_descriptors_x</code> <code>Sequence[HaloExchangeSpec]</code> <p>list of memory information describing an exchange. Used for scalar data and the x-component of vectors.</p> required <code>exchange_descriptors_y</code> <code>Sequence[HaloExchangeSpec] | None</code> <p>list of memory information describing an exchange. Optional, used for the y-component of vectors only. If <code>none</code> the data will packed as a scalar.</p> <code>None</code> <p>Returns:</p> Type Description <code>HaloDataTransformer</code> <p>an initialized packed buffer.</p>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer.get_pack_buffer","title":"<code>get_pack_buffer()</code>","text":"<p>Retrieve pack buffer.</p> <p>Synchronizes operations.</p>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer.get_unpack_buffer","title":"<code>get_unpack_buffer()</code>","text":"<p>Retrieve unpack buffer.</p> <p>Synchronizes operations.</p>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer.ready","title":"<code>ready()</code>","text":"<p>Check if the buffers are ready for communication.</p>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformer.synchronize","title":"<code>synchronize()</code>  <code>abstractmethod</code>","text":"<p>Synchronize all operations.</p> <p>Guarantees all memory is now safe to access.</p>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformerCPU","title":"<code>HaloDataTransformerCPU</code>","text":"<p>               Bases: <code>HaloDataTransformer</code></p> <p>Pack/unpack data in a single buffer using numpy flattening &amp; slicing.</p> <p>Default behavior, could be done with any numpy-like library.</p>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformerGPU","title":"<code>HaloDataTransformerGPU</code>","text":"<p>               Bases: <code>HaloDataTransformer</code></p> <p>Pack/unpack data in a single buffer using CUDA Kernels.</p> <p>In order to efficiently pack/unpack on the GPU to a single GPU buffer we use streamed (e.g. async) kernels per quantity per edge to send. The kernels are store in <code>cuda_kernels.py</code>, they both follow the same simple pattern by reading the indices to the device memory of the data to pack/unpack. <code>_flatten_indices</code> is the routine that take the layout of the memory and the slice and compute an array of index into the original memory.</p>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformerGPU.async_pack","title":"<code>async_pack(quantities_x, quantities_y=None)</code>","text":"<p>Pack the quantities into a single buffer via streamed cuda kernels</p> <p>Writes into self._pack_buffer using self._x_infos and self._y_infos to read the offsets and sizes per quantity.</p> <p>Parameters:</p> Name Type Description Default <code>quantities_x</code> <code>list[Quantity]</code> <p>list of quantities to pack. Must fit the specifications given at init time.</p> required <code>quantities_y</code> <code>list[Quantity] | None</code> <p>Same as above but optional, used only for vector transfer.</p> <code>None</code>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloDataTransformerGPU.async_unpack","title":"<code>async_unpack(quantities_x, quantities_y=None)</code>","text":"<p>Unpack the quantities from a single buffer via streamed cuda kernels</p> <p>Reads from self._unpack_buffer using self._x_infos and self._y_infos to read the offsets and sizes per quantity.</p> <p>Parameters:</p> Name Type Description Default <code>quantities_x</code> <code>list[Quantity]</code> <p>list of quantities to unpack. Must fit the specifications given at init time.</p> required <code>quantities_y</code> <code>list[Quantity] | None</code> <p>Same as above but optional, used only for vector transfer.</p> <code>None</code>"},{"location":"docstrings/halo/data_transformer/#halo.data_transformer.HaloExchangeSpec","title":"<code>HaloExchangeSpec</code>  <code>dataclass</code>","text":"<p>Memory description of the data exchanged.</p> <p>The data stored here target a single exchange, with an optional rotation to give prior to pack. Slices are tupled following the convention of one slice per dimension</p> <p>Parameters:</p> Name Type Description Default <code>specification</code> <code>QuantityHaloSpec</code> <p>memory layout of the data</p> required <code>pack_slices</code> <code>tuple[slice, ...]</code> <p>indexing to pack, one slice per dimension</p> required <code>pack_clockwise_rotation</code> <code>int</code> <p>number of 90-degree rotations to perform before packing</p> required <code>unpack_slices</code> <code>tuple[slice, ...]</code> <p>indexing to unpack, one slice per dimension</p> required"},{"location":"docstrings/halo/rotate/","title":"rotate","text":""},{"location":"docstrings/halo/updater/","title":"updater","text":""},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdateRequest","title":"<code>HaloUpdateRequest</code>","text":"<p>Asynchronous request object for halo updates.</p>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdateRequest.__init__","title":"<code>__init__(send_data, recv_data, timer=None)</code>","text":"<p>Build a halo request. Args:     send_data: a tuple of the MPI request and the buffer sent     recv_data: a tuple of the MPI request, the temporary buffer and         the destination buffer     timer: optional, time the wait &amp; unpack of a halo exchange</p>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdateRequest.wait","title":"<code>wait()</code>","text":"<p>Wait &amp; unpack data into destination buffers Clean up by inserting back all buffers back in cache for potential reuse</p>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdater","title":"<code>HaloUpdater</code>","text":"<p>Exchange halo information between ranks.</p> <p>The class is responsible for the entire exchange and uses the init to precompute the maximum of information to have minimum overhead at runtime. Therefore it should be cached for early and re-used at runtime.</p> <ul> <li>from_scalar_specifications/from_vector_specifications are used to   create a HaloUpdater from a list of memory specifications</li> <li>update and start/wait trigger the halo exchange</li> <li>the class creates a \"pattern\" of exchange that can fit   any memory given to do/start</li> <li>temporary references to the Quantities are held between start and wait</li> </ul>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdater.__del__","title":"<code>__del__()</code>","text":"<p>Clean up all buffers on garbage collection</p>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdater.__init__","title":"<code>__init__(comm, tag, transformers, timer)</code>","text":"<p>Build the updater.</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>Communicator</code> <p>communicator responsible for send/recv commands.</p> required <code>tag</code> <code>int</code> <p>network tag to be used for communication</p> required <code>transformers</code> <code>dict[int, HaloDataTransformer]</code> <p>mapping from destination rank to transformers used to pack/unpack before and after communication</p> required <code>timer</code> <code>Timer</code> <p>timing operations</p> required"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdater.force_finalize_on_wait","title":"<code>force_finalize_on_wait()</code>","text":"<p>HaloDataTransformer are finalized after a wait call</p> <p>This is a temporary fix. See DSL-816 which will remove self._finalize_on_wait.</p>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdater.from_scalar_specifications","title":"<code>from_scalar_specifications(comm, numpy_like_module, specifications, boundaries, tag, optional_timer=None)</code>  <code>classmethod</code>","text":"<p>Create/retrieve as many packed buffer as needed and queue the slices to exchange.</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>Communicator</code> <p>communicator to post network messages</p> required <code>numpy_like_module</code> <code>NumpyModule</code> <p>module implementing numpy API</p> required <code>specifications</code> <code>Iterable[QuantityHaloSpec]</code> <p>data specifications to exchange, including number of halo points</p> required <code>boundaries</code> <code>Iterable[Boundary]</code> <p>information on the exchange boundaries.</p> required <code>tag</code> <code>int</code> <p>network tag (to differentiate messaging) for this node.</p> required <code>optional_timer</code> <code>Timer | None</code> <p>timing of operations.</p> <code>None</code> <p>Returns:</p> Type Description <code>HaloUpdater</code> <p>HaloUpdater ready to exchange data.</p>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdater.from_vector_specifications","title":"<code>from_vector_specifications(comm, numpy_like_module, specifications_x, specifications_y, boundaries, tag, optional_timer=None)</code>  <code>classmethod</code>","text":"<p>Create/retrieve as many packed buffer as needed and queue the slices to exchange.</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>Communicator</code> <p>communicator to post network messages</p> required <code>numpy_like_module</code> <code>NumpyModule</code> <p>module implementing numpy API</p> required <code>specifications_x</code> <code>Iterable[QuantityHaloSpec]</code> <p>specifications to exchange along the x axis. Length must match y specifications.</p> required <code>specifications_y</code> <code>Iterable[QuantityHaloSpec]</code> <p>specifications to exchange along the y axis. Length must match x specifications.</p> required <code>boundaries</code> <code>Iterable[Boundary]</code> <p>information on the exchange boundaries.</p> required <code>tag</code> <code>int</code> <p>network tag (to differentiate messaging) for this node.</p> required <code>optional_timer</code> <code>Timer | None</code> <p>timing of operations.</p> <code>None</code> <p>Returns:</p> Type Description <code>HaloUpdater</code> <p>HaloUpdater ready to exchange data.</p>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdater.start","title":"<code>start(quantities_x, quantities_y=None)</code>","text":"<p>Start data exchange.</p>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdater.update","title":"<code>update(quantities_x, quantities_y=None)</code>","text":"<p>Exchange the data and blocks until finished.</p>"},{"location":"docstrings/halo/updater/#halo.updater.HaloUpdater.wait","title":"<code>wait()</code>","text":"<p>Finalize data exchange.</p>"},{"location":"docstrings/halo/updater/#halo.updater.VectorInterfaceHaloUpdater","title":"<code>VectorInterfaceHaloUpdater</code>","text":""},{"location":"docstrings/halo/updater/#halo.updater.VectorInterfaceHaloUpdater.__init__","title":"<code>__init__(comm, boundaries, force_cpu=False, timer=None)</code>","text":"<p>Initialize a CubedSphereCommunicator.</p> <p>Parameters:</p> Name Type Description Default <code>comm</code> <code>Comm</code> <p>mpi4py.Comm object</p> required <code>partitioner</code> <p>cubed sphere partitioner</p> required <code>force_cpu</code> <code>bool</code> <p>Force all communication to go through central memory. Optional.</p> <code>False</code> <code>timer</code> <code>Timer | None</code> <p>Time communication operations. Optional.</p> <code>None</code>"},{"location":"docstrings/halo/updater/#halo.updater.VectorInterfaceHaloUpdater.start_synchronize_vector_interfaces","title":"<code>start_synchronize_vector_interfaces(x_quantity, y_quantity)</code>","text":"<p>Synchronize shared points at the edges of a vector interface variable.</p> <p>Sends the values on the south and west edges to overwrite the values on adjacent subtiles. Vector must be defined on the Arakawa C grid.</p> <p>For interface variables, the edges of the tile are computed on both ranks bordering that edge. This routine copies values across those shared edges so that both ranks have the same value for that edge. It also handles any rotation of vector quantities needed to move data across the edge.</p> <p>Parameters:</p> Name Type Description Default <code>x_quantity</code> <code>Quantity</code> <p>the x-component quantity to be synchronized</p> required <code>y_quantity</code> <code>Quantity</code> <p>the y-component quantity to be synchronized</p> required <p>Returns:</p> Name Type Description <code>request</code> <code>HaloUpdateRequest</code> <p>an asynchronous request object with a .wait() method</p>"},{"location":"docstrings/initialization/allocator/","title":"allocator","text":""},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory","title":"<code>QuantityFactory</code>","text":""},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.__init__","title":"<code>__init__(sizer, *, backend)</code>","text":"<p>Initialize a QuantityFactory from a GridSizer and a GT4Py backend name.</p> <p>Parameters:</p> Name Type Description Default <code>sizer</code> <code>GridSizer</code> <p>GridSizer object that determines the array sizes.</p> required <code>backend</code> <code>str</code> <p>GT4Py backend name used for performance-optimized allocation.</p> required"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.add_data_dimensions","title":"<code>add_data_dimensions(data_dimension_descriptions)</code>","text":"<p>Add new data (non-x/y/z) dimensions via a key-length pair. If the dimension already exists, it will error out.</p> <p>Parameters:</p> Name Type Description Default <code>data_dimension_descriptions</code> <code>dict[str, int]</code> <p>Dict of name/length pairs</p> required"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.empty","title":"<code>empty(dims, units, dtype=Float, *, allow_mismatch_float_precision=False)</code>","text":"<p>Allocate a Quantity and fill it with uninitialized (undefined) values.</p> <p>Equivalent to <code>numpy.empty</code></p>"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.from_array","title":"<code>from_array(data, dims, units, *, allow_mismatch_float_precision=False)</code>","text":"<p>Create a Quantity from values in the <code>data</code> array.</p> <p>This copies the values of <code>data</code> into the resulting Quantity. The data array thus must correspond to the correct shape and extent for the given dims.</p>"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.from_backend","title":"<code>from_backend(sizer, backend)</code>  <code>classmethod</code>","text":"<p>Initialize a QuantityFactory to use a specific GT4Py backend.</p> <p>Note: This method is deprecated. Please change your code to use the constructor instead.</p> <p>Parameters:</p> Name Type Description Default <code>sizer</code> <code>GridSizer</code> <p>GridSizer object that determines the array sizes.</p> required <code>backend</code> <code>str</code> <p>GT4Py backend name used for performance-optimized allocation.</p> required"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.from_compute_array","title":"<code>from_compute_array(data, dims, units, *, allow_mismatch_float_precision=False)</code>","text":"<p>Create a Quantity from values of the compute domain.</p> <p>This function will allocate the full Quantity (including potential halo points) to zero. The values of <code>data</code> are then copied into the compute domain. That numpy array must correspond to the correct shape and extent of the compute domain for the given dims.</p>"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.full","title":"<code>full(dims, units, value, dtype=Float, *, allow_mismatch_float_precision=False)</code>","text":"<p>Allocate a Quantity and fill it with the given value.</p> <p>Equivalent to <code>numpy.full</code></p>"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.get_quantity_halo_spec","title":"<code>get_quantity_halo_spec(dims, n_halo=None, dtype=Float)</code>","text":"<p>Build memory specifications for the halo update.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Sequence[str]</code> <p>dimensionality of the data</p> required <code>n_halo</code> <code>int | None</code> <p>number of halo points to update, defaults to self.n_halo</p> <code>None</code> <code>dtype</code> <code>type</code> <p>data type of the data</p> <code>Float</code> <code>backend</code> <p>gt4py backend to use</p> required"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.ones","title":"<code>ones(dims, units, dtype=Float, *, allow_mismatch_float_precision=False)</code>","text":"<p>Allocate a Quantity and fill it with the value 1.</p> <p>Equivalent to <code>numpy.ones</code></p>"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.update_data_dimensions","title":"<code>update_data_dimensions(data_dimension_descriptions)</code>","text":"<p>Update the length of data (non-x/y/z) dimensions, unknown data dimensions will be added, existing ones updated.</p> <p>Parameters:</p> Name Type Description Default <code>data_dimension_descriptions</code> <code>dict[str, int]</code> <p>Dict of name/length pairs</p> required"},{"location":"docstrings/initialization/allocator/#initialization.allocator.QuantityFactory.zeros","title":"<code>zeros(dims, units, dtype=Float, *, allow_mismatch_float_precision=False)</code>","text":"<p>Allocate a Quantity and fill it with the value 0.</p> <p>Equivalent to <code>numpy.zeros</code></p>"},{"location":"docstrings/initialization/grid_sizer/","title":"grid_sizer","text":""},{"location":"docstrings/initialization/grid_sizer/#initialization.grid_sizer.GridSizer","title":"<code>GridSizer</code>  <code>dataclass</code>","text":""},{"location":"docstrings/initialization/grid_sizer/#initialization.grid_sizer.GridSizer.data_dimensions","title":"<code>data_dimensions</code>  <code>instance-attribute</code>","text":"<p>Name/Lengths pair of any non-x/y/z dimensions, such as land or radiation dimensions.</p>"},{"location":"docstrings/initialization/grid_sizer/#initialization.grid_sizer.GridSizer.n_halo","title":"<code>n_halo</code>  <code>instance-attribute</code>","text":"<p>Number of horizontal halo points for produced arrays.</p>"},{"location":"docstrings/initialization/grid_sizer/#initialization.grid_sizer.GridSizer.nx","title":"<code>nx</code>  <code>instance-attribute</code>","text":"<p>Length of the x compute dimension for produced arrays.</p>"},{"location":"docstrings/initialization/grid_sizer/#initialization.grid_sizer.GridSizer.ny","title":"<code>ny</code>  <code>instance-attribute</code>","text":"<p>Length of the y compute dimension for produced arrays.</p>"},{"location":"docstrings/initialization/grid_sizer/#initialization.grid_sizer.GridSizer.nz","title":"<code>nz</code>  <code>instance-attribute</code>","text":"<p>Length of the z compute dimension for produced arrays.</p>"},{"location":"docstrings/initialization/subtile_grid_sizer/","title":"subtile_grid_sizer","text":""},{"location":"docstrings/initialization/subtile_grid_sizer/#initialization.subtile_grid_sizer.SubtileGridSizer","title":"<code>SubtileGridSizer</code>","text":"<p>               Bases: <code>GridSizer</code></p>"},{"location":"docstrings/initialization/subtile_grid_sizer/#initialization.subtile_grid_sizer.SubtileGridSizer.from_namelist","title":"<code>from_namelist(namelist, tile_partitioner=None, tile_rank=0)</code>  <code>classmethod</code>","text":"<p>Create a SubtileGridSizer from a Fortran namelist.</p> <p>Parameters:</p> Name Type Description Default <code>namelist</code> <code>dict</code> <p>A namelist for the fv3gfs fortran model</p> required <code>tile_partitioner</code> <code>optional</code> <p>a partitioner to use for segmenting the tile. By default, a TilePartitioner is used.</p> <code>None</code> <code>tile_rank</code> <code>optional</code> <p>current rank on tile. Default is 0. Only matters if different ranks have different domain shapes. If tile_partitioner is a TilePartitioner, this argument does not matter.</p> <code>0</code>"},{"location":"docstrings/initialization/subtile_grid_sizer/#initialization.subtile_grid_sizer.SubtileGridSizer.from_tile_params","title":"<code>from_tile_params(nx_tile, ny_tile, nz, n_halo, layout, *, data_dimensions=None, tile_partitioner=None, tile_rank=0, extra_dim_lengths=None)</code>  <code>classmethod</code>","text":"<p>Create a SubtileGridSizer from parameters about the full tile.</p> <p>Parameters:</p> Name Type Description Default <code>nx_tile</code> <code>int</code> <p>number of x cell centers on the tile</p> required <code>ny_tile</code> <code>int</code> <p>number of y cell centers on the tile</p> required <code>nz</code> <code>int</code> <p>number of vertical levels</p> required <code>n_halo</code> <code>int</code> <p>number of halo points</p> required <code>data_dimensions</code> <code>dict[str, int] | None</code> <p>lengths of any non-x/y/z dimensions, such as land or radiation dimensions</p> <code>None</code> <code>layout</code> <code>tuple[int, int]</code> <p>(y, x) number of ranks along tile edges</p> required <code>tile_partitioner</code> <code>optional</code> <p>partitioner object for the tile. By default, a TilePartitioner is created with the given layout</p> <code>None</code> <code>tile_rank</code> <code>optional</code> <p>rank of this subtile.</p> <code>0</code> <code>extra_dim_lengths</code> <code>dict[str, int] | None</code> <p>DEPRECATED API - use <code>data_dimensions</code></p> <code>None</code>"},{"location":"docstrings/monitor/convert/","title":"convert","text":""},{"location":"docstrings/monitor/convert/#monitor.convert.to_numpy","title":"<code>to_numpy(array, dtype=None)</code>","text":"<p>Input array can be a numpy array or a cupy array. Returns numpy array.</p>"},{"location":"docstrings/monitor/netcdf_monitor/","title":"netcdf_monitor","text":""},{"location":"docstrings/monitor/netcdf_monitor/#monitor.netcdf_monitor.NetCDFMonitor","title":"<code>NetCDFMonitor</code>","text":"<p>sympl.Monitor-style object for storing model state dictionaries netCDF files.</p>"},{"location":"docstrings/monitor/netcdf_monitor/#monitor.netcdf_monitor.NetCDFMonitor.__init__","title":"<code>__init__(path, communicator, time_chunk_size=1, precision=Float)</code>","text":"<p>Create a NetCDFMonitor.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>directory in which to store data</p> required <code>communicator</code> <code>Communicator</code> <p>provides global communication to gather state</p> required <code>time_chunk_size</code> <code>int</code> <p>number of times per file</p> <code>1</code>"},{"location":"docstrings/monitor/netcdf_monitor/#monitor.netcdf_monitor.NetCDFMonitor.store","title":"<code>store(state)</code>","text":"<p>Append the model state dictionary to the netcdf files.</p> <p>Will only write to disk when a full time chunk has been accumulated, or when .cleanup() is called.</p> <p>Requires the state contain the same quantities with the same metadata as the first time this is called. Dimension order metadata may change between calls so long as the set of dimensions is the same. Quantities are stored with dimensions [time, tile] followed by the dimensions included in the first state snapshot. The one exception is \"time\" which is stored with dimensions [time].</p>"},{"location":"docstrings/monitor/protocol/","title":"protocol","text":""},{"location":"docstrings/monitor/protocol/#monitor.protocol.Monitor","title":"<code>Monitor</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>sympl.Monitor-style object for storing model state dictionaries.</p>"},{"location":"docstrings/monitor/protocol/#monitor.protocol.Monitor.store","title":"<code>store(state)</code>","text":"<p>Append the model state dictionary to the stored data.</p>"},{"location":"docstrings/monitor/zarr_monitor/","title":"zarr_monitor","text":""},{"location":"docstrings/monitor/zarr_monitor/#monitor.zarr_monitor.DummyComm","title":"<code>DummyComm</code>","text":"<p>               Bases: <code>Comm[T]</code></p> <p>Dummy comm object that works in single-core mode.</p>"},{"location":"docstrings/monitor/zarr_monitor/#monitor.zarr_monitor.ZarrMonitor","title":"<code>ZarrMonitor</code>","text":"<p>sympl.Monitor-style object for storing model state dictionaries in a Zarr store.</p>"},{"location":"docstrings/monitor/zarr_monitor/#monitor.zarr_monitor.ZarrMonitor.__init__","title":"<code>__init__(store, partitioner, mode='w', mpi_comm=None)</code>","text":"<p>Create a ZarrMonitor.</p> <p>Parameters:</p> Name Type Description Default <code>store</code> <code>str | MutableMapping</code> <p>Zarr store in which to store data</p> required <code>partitioner</code> <code>Partitioner</code> <p>object providing grid layout information to the Monitor</p> required <code>mode</code> <code>str</code> <p>mode to use to open the store. Options are as in zarr.open_group.</p> <code>'w'</code> <code>mpi_comm</code> <code>Comm | None</code> <p>mpi4py comm object to use for communications. By default, will use a dummy comm object that works in single-core mode.</p> <code>None</code>"},{"location":"docstrings/monitor/zarr_monitor/#monitor.zarr_monitor.ZarrMonitor.store","title":"<code>store(state)</code>","text":"<p>Append the model state dictionary to the zarr store.</p> <p>Requires the state contain the same quantities with the same metadata as the first time this is called. Dimension order metadata may change between calls so long as the set of dimensions is the same. Quantities are stored with dimensions [time, rank] followed by the dimensions included in the first state snapshot. The one exception is \"time\" which is stored with dimensions [time].</p>"},{"location":"docstrings/performance/collector/","title":"collector","text":""},{"location":"docstrings/performance/collector/#performance.collector.PerformanceCollector","title":"<code>PerformanceCollector</code>","text":"<p>               Bases: <code>AbstractPerformanceCollector</code></p>"},{"location":"docstrings/performance/collector/#performance.collector.PerformanceCollector.collect_performance","title":"<code>collect_performance()</code>","text":"<p>Take the accumulated timings and flush them into a new entry in times_per_step and hits_per_step.</p>"},{"location":"docstrings/performance/config/","title":"config","text":""},{"location":"docstrings/performance/config/#performance.config.PerformanceConfig","title":"<code>PerformanceConfig</code>  <code>dataclass</code>","text":"<p>Performance stats collector.</p> <p>collect_performance: overall flag turning collection on/pff collect_cProfile: use cProfile for CPU Python profiling collect_communication: collect halo exchange details experiment_name: to be printed in the JSON summary json_all_rank_threshold: number of nodes above the full performance     report for all nodes won't be written (rank 0 is always written)</p>"},{"location":"docstrings/performance/profiler/","title":"profiler","text":""},{"location":"docstrings/performance/profiler/#performance.profiler.NullProfiler","title":"<code>NullProfiler</code>","text":"<p>A profiler class which does not actually profile anything.</p> <p>Meant to be used in place of an optional profiler.</p>"},{"location":"docstrings/performance/profiler/#performance.profiler.NullProfiler.enabled","title":"<code>enabled</code>  <code>property</code>","text":"<p>Indicates whether the profiler is enabled.</p>"},{"location":"docstrings/performance/profiler/#performance.profiler.Profiler","title":"<code>Profiler</code>","text":""},{"location":"docstrings/performance/profiler/#performance.profiler.Profiler.enabled","title":"<code>enabled</code>  <code>property</code>","text":"<p>Indicates whether the profiler is currently enabled.</p>"},{"location":"docstrings/performance/report/","title":"report","text":""},{"location":"docstrings/performance/report/#performance.report.collect_data_and_write_to_file","title":"<code>collect_data_and_write_to_file(time_step, backend, is_orchestrated, git_hash, comm, hits_per_step, times_per_step, experiment_name, dt_atmos)</code>","text":"<p>collect the gathered data from all the ranks onto rank 0 and write the timing file</p>"},{"location":"docstrings/performance/report/#performance.report.collect_keys_from_data","title":"<code>collect_keys_from_data(times_per_step)</code>","text":"<p>Collects all the keys in the list of dicts and returns a sorted version</p>"},{"location":"docstrings/performance/report/#performance.report.gather_hit_counts","title":"<code>gather_hit_counts(hits_per_step, timing_info)</code>","text":"<p>collects the hit count across all timers called in a program execution</p>"},{"location":"docstrings/performance/report/#performance.report.gather_timing_data","title":"<code>gather_timing_data(times_per_step, comm, root=0)</code>","text":"<p>returns an updated version of the results dictionary owned by the root node to hold data on the substeps as well as the main loop timers</p>"},{"location":"docstrings/performance/timer/","title":"timer","text":""},{"location":"docstrings/performance/timer/#performance.timer.NullTimer","title":"<code>NullTimer</code>","text":"<p>               Bases: <code>Timer</code></p> <p>A Timer class which does not actually accumulate timings.</p> <p>Meant to be used in place of an optional timer.</p>"},{"location":"docstrings/performance/timer/#performance.timer.NullTimer.enabled","title":"<code>enabled</code>  <code>property</code>","text":"<p>Indicates whether the timer is currently enabled.</p>"},{"location":"docstrings/performance/timer/#performance.timer.NullTimer.enable","title":"<code>enable()</code>","text":"<p>Enable the Timer.</p>"},{"location":"docstrings/performance/timer/#performance.timer.Timer","title":"<code>Timer</code>","text":"<p>Class to accumulate timings for named operations.</p>"},{"location":"docstrings/performance/timer/#performance.timer.Timer.enabled","title":"<code>enabled</code>  <code>property</code>","text":"<p>Indicates whether the timer is currently enabled.</p>"},{"location":"docstrings/performance/timer/#performance.timer.Timer.hits","title":"<code>hits</code>  <code>property</code>","text":"<p>accumulated hit counts for each operation name</p>"},{"location":"docstrings/performance/timer/#performance.timer.Timer.times","title":"<code>times</code>  <code>property</code>","text":"<p>accumulated timings for each operation name</p>"},{"location":"docstrings/performance/timer/#performance.timer.Timer.clock","title":"<code>clock(name)</code>","text":"<p>Context manager to produce timings of operations.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name of the operation being timed</p> required <p>Example</p> <p>The context manager times operations that happen within its context. The following would time a time.sleep operation::</p> <pre><code>&gt;&gt;&gt; import time\n&gt;&gt;&gt; from ndsl.performance.timer import Timer\n&gt;&gt;&gt; timer = Timer()\n&gt;&gt;&gt; with timer.clock(\"sleep\"):\n...     time.sleep(1)\n...\n&gt;&gt;&gt; timer.times\n{'sleep': 1.0032463260000029}\n</code></pre>"},{"location":"docstrings/performance/timer/#performance.timer.Timer.disable","title":"<code>disable()</code>","text":"<p>Disable the Timer.</p>"},{"location":"docstrings/performance/timer/#performance.timer.Timer.enable","title":"<code>enable()</code>","text":"<p>Enable the Timer.</p>"},{"location":"docstrings/performance/timer/#performance.timer.Timer.reset","title":"<code>reset()</code>","text":"<p>Remove all accumulated timings.</p>"},{"location":"docstrings/performance/timer/#performance.timer.Timer.start","title":"<code>start(name)</code>","text":"<p>Start timing a given named operation.</p>"},{"location":"docstrings/performance/timer/#performance.timer.Timer.stop","title":"<code>stop(name)</code>","text":"<p>Stop timing a given named operation, add the time elapsed to accumulated timing and increase the hit count.</p>"},{"location":"docstrings/performance/tools/","title":"tools","text":""},{"location":"docstrings/performance/tools/#performance.tools.command_line","title":"<code>command_line(action, sdfg_path, report_detail, hardware_bw_in_gb_s, output_format, backend)</code>","text":"<p>Run tooling.</p>"},{"location":"docstrings/quantity/bounds/","title":"bounds","text":""},{"location":"docstrings/quantity/bounds/#quantity.bounds.BoundaryArrayView","title":"<code>BoundaryArrayView</code>","text":""},{"location":"docstrings/quantity/bounds/#quantity.bounds.BoundaryArrayView.sel","title":"<code>sel(**kwargs)</code>","text":"<p>Convenience method to perform indexing using dimension names without knowing dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>slice | int</code> <p>slice/index to retrieve for a given dimension name</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>view_selection</code> <code>ndarray</code> <p>an ndarray-like selection of the given indices on <code>self.view</code></p>"},{"location":"docstrings/quantity/bounds/#quantity.bounds.BoundedArrayView","title":"<code>BoundedArrayView</code>","text":"<p>A container of objects which provide indexing relative to corners and edges of the computational domain for convenience.</p> <p>Default start and end indices for all dimensions are modified to be the start and end of the compute domain. When using edge and corner attributes, it is recommended to explicitly write start and end offsets to avoid confusion.</p> <p>Indexing on the object itself (view[:]) is offset by the origin, and default start and end indices are modified to be the start and end of the compute domain.</p> <p>For corner attributes e.g. <code>northwest</code>, modified indexing is done for the two axes according to the edges which make up the corner. In other words, indexing is offset relative to the intersection of the two edges which make the corner.</p> <p>For <code>interior</code>, start indices of the horizontal dimensions are relative to the origin, and end indices are relative to the origin + extent. For example, view.interior[0:0, 0:0, :] would retrieve the entire compute domain for an x/y/z array, while view.interior[-1:1, -1:1, :] would also include one halo point.</p>"},{"location":"docstrings/quantity/bounds/#quantity.bounds.BoundedArrayView.extent","title":"<code>extent</code>  <code>property</code>","text":"<p>the shape of the computational domain</p>"},{"location":"docstrings/quantity/bounds/#quantity.bounds.BoundedArrayView.origin","title":"<code>origin</code>  <code>property</code>","text":"<p>the start of the computational domain</p>"},{"location":"docstrings/quantity/field_bundle/","title":"field_bundle","text":""},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle","title":"<code>FieldBundle</code>","text":"<p>Field Bundle wraps a nD array (3D + n Data Dimensions) into a complex indexing scheme that allows a dual name-based and index-based access to the underlying memory. It is paired with the <code>FieldBundleType</code> which provides a way to type hint parameters for stencils in the <code>gtscript</code>.</p> <p>WARNING: The present implementation only allows for 4D array.</p>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle.__array_interface__","title":"<code>__array_interface__</code>  <code>property</code>","text":"<p>Memory interface for CPU.</p>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle.__cuda_array_interface__","title":"<code>__cuda_array_interface__</code>  <code>property</code>","text":"<p>Memory interface for GPU memory as defined by cupy.</p>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle.__descriptor__","title":"<code>__descriptor__()</code>","text":"<p>Data descriptor for DaCe.</p>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Allow to reference sub-array using <code>field.a_name</code></p>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle.__init__","title":"<code>__init__(bundle_name, quantity, mapping=None, register_type=False)</code>","text":"<p>Initialize a bundle from a nD quantity.</p> <p>Dev note: current implementation limits to 4D inputs.</p> <p>Parameters:</p> Name Type Description Default <code>bundle_name</code> <code>str</code> <p>name of the bundle, accessible via <code>name</code>.</p> required <code>quantity</code> <code>Quantity</code> <p>data inputs as a nD array.</p> required <code>mapping</code> <code>_FieldBundleIndexer | None</code> <p>sparse dict of [name, index] to be able to call tracers by name.</p> <code>None</code> <code>register_type</code> <code>bool</code> <p>boolean to register the type as part of initialization.</p> <code>False</code>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle.extend_3D_quantity_factory","title":"<code>extend_3D_quantity_factory(quantity_factory, extra_dims)</code>  <code>staticmethod</code>","text":"<p>Create a nD quantity factory from a cartesian 3D factory.</p> <p>Parameters:</p> Name Type Description Default <code>quantity_factory</code> <code>QuantityFactory</code> <p>Cartesian 3D factory.</p> required <code>extra_dims</code> <code>dict[str, int]</code> <p>dict of [name, size] of the data dimensions to add.</p> required"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle.groupby","title":"<code>groupby(name)</code>","text":"<p>Not implemented</p>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle.index","title":"<code>index(name)</code>","text":"<p>Get index from name.</p>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundle.map","title":"<code>map(index, name)</code>","text":"<p>Map a single <code>index</code> to <code>name</code></p>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundleType","title":"<code>FieldBundleType</code>","text":"<p>Field Bundle Types to help with static sizing of Data Dimensions.</p> <p>Methods:</p> Name Description <code>register</code> <p>Register a type by sizing its data dimensions</p> <code>T</code> <p>access any registered types for type hinting.</p>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundleType.T","title":"<code>T(name, do_markup=True)</code>  <code>classmethod</code>","text":"<p>Get registered type.</p> <p>Dev note: The markup feature is to allow early parsing (at file import) to go ahead - while we will resolve the full type when calling the stencil.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of the type as registered via <code>register</code></p> required <code>do_markup</code> <code>bool</code> <p>if name not registered, markup for a future specialization at stencil call time</p> <code>True</code>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.FieldBundleType.register","title":"<code>register(name, data_dims, dtype=Float)</code>  <code>classmethod</code>","text":"<p>Register a name type by name by giving the size of its data dimensions.</p> <p>The same type cannot be registered twice and will error out.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Type name, to be re-used with <code>T</code>.</p> required <code>data_dims</code> <code>tuple[int]</code> <p>tuple of int giving size of each data dimensions.</p> required <code>dtype</code> <p>Inner data type, defaults to Float.</p> <code>Float</code>"},{"location":"docstrings/quantity/field_bundle/#quantity.field_bundle.MarkupFieldBundleType","title":"<code>MarkupFieldBundleType</code>  <code>dataclass</code>","text":"<p>Markup a field bundle to delay specialization.</p> <p>Properties</p> <p>name: name of the future type to look into the registrar.</p>"},{"location":"docstrings/quantity/metadata/","title":"metadata","text":""},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityHaloSpec","title":"<code>QuantityHaloSpec</code>  <code>dataclass</code>","text":"<p>Describe the memory to be exchanged, including size of the halo.</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata","title":"<code>QuantityMetadata</code>  <code>dataclass</code>","text":""},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.data_type","title":"<code>data_type</code>  <code>instance-attribute</code>","text":"<p>ndarray-like type used to store the data</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.dim_lengths","title":"<code>dim_lengths</code>  <code>property</code>","text":"<p>mapping of dimension names to their lengths</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.dims","title":"<code>dims</code>  <code>instance-attribute</code>","text":"<p>names of each dimension</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.dtype","title":"<code>dtype</code>  <code>instance-attribute</code>","text":"<p>dtype of the data in the ndarray-like object</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.extent","title":"<code>extent</code>  <code>instance-attribute</code>","text":"<p>the shape of the computational domain</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.gt4py_backend","title":"<code>gt4py_backend = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>backend to use for gt4py storages</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.n_halo","title":"<code>n_halo</code>  <code>instance-attribute</code>","text":"<p>Number of halo-points used in the horizontal</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.np","title":"<code>np</code>  <code>property</code>","text":"<p>numpy-like module used to interact with the data</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.origin","title":"<code>origin</code>  <code>instance-attribute</code>","text":"<p>the start of the computational domain</p>"},{"location":"docstrings/quantity/metadata/#quantity.metadata.QuantityMetadata.units","title":"<code>units</code>  <code>instance-attribute</code>","text":"<p>units of the quantity</p>"},{"location":"docstrings/quantity/quantity/","title":"quantity","text":""},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity","title":"<code>Quantity</code>","text":"<p>Data container for physical quantities.</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.data","title":"<code>data</code>  <code>property</code> <code>writable</code>","text":"<p>The underlying array of data</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.data_as_xarray","title":"<code>data_as_xarray</code>  <code>property</code>","text":"<p>Returns an Xarray.DataArray of the underlying array</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.dims","title":"<code>dims</code>  <code>property</code>","text":"<p>Names of each dimension</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.extent","title":"<code>extent</code>  <code>property</code>","text":"<p>The shape of the computational domain</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.field_as_xarray","title":"<code>field_as_xarray</code>  <code>property</code>","text":"<p>Returns an Xarray.DataArray of the field (domain)</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.origin","title":"<code>origin</code>  <code>property</code>","text":"<p>The start of the computational domain</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.units","title":"<code>units</code>  <code>property</code>","text":"<p>Units of the quantity</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.view","title":"<code>view</code>  <code>property</code>","text":"<p>A view into the computational domain of the underlying data</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.__descriptor__","title":"<code>__descriptor__()</code>","text":"<p>The descriptor is a property that dace uses.</p> <p>This relies on <code>dace</code> capacity to read out data from the buffer protocol. If the internal data given doesn't follow the protocol it will most likely fail.</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.__init__","title":"<code>__init__(data, dims, units, origin=None, extent=None, gt4py_backend=None, allow_mismatch_float_precision=False, number_of_halo_points=0)</code>","text":"<p>Initialize a Quantity.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>_type_</code> <p>ndarray-like object containing the underlying data</p> required <code>dims</code> <code>Sequence[str]</code> <p>dimension names for each axis</p> required <code>units</code> <code>str</code> <p>units of the quantity</p> required <code>origin</code> <code>Sequence[int] | None</code> <p>first point in data within the</p> <code>None</code> <code>extent</code> <code>Sequence[int] | None</code> <p>number of points along each axis within the computational domain. Defaults to None.</p> <code>None</code> <code>gt4py_backend</code> <code>str | None</code> <p>backend to use for gt4py storages, if not given this will be derived from a Storage if given as the data argument. Defaults to None.</p> <code>None</code> <code>allow_mismatch_float_precision</code> <code>bool</code> <p>allow for precision that is not the simulation-wide default configuration. Defaults to False.</p> <code>False</code> <code>number_of_halo_points</code> <code>int</code> <p>Number of halo points used. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Data-type mismatch between configuration and input-data</p> <code>TypeError</code> <p>Typing of the data that does not fit</p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.from_data_array","title":"<code>from_data_array(data_array, origin=None, extent=None, gt4py_backend=None, number_of_halo_points=0)</code>  <code>classmethod</code>","text":"<p>Initialize a Quantity from an xarray.DataArray.</p> <p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Sequence[int] | None</code> <p>first point in data within the computational domain</p> <code>None</code> <code>extent</code> <code>Sequence[int] | None</code> <p>number of points along each axis within the computational domain</p> <code>None</code> <code>gt4py_backend</code> <code>str | None</code> <p>backend to use for gt4py storages, if not given this will be derived from a Storage if given as the data argument, otherwise the storage attribute is disabled and will raise an exception</p> <code>None</code>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.sel","title":"<code>sel(**kwargs)</code>","text":"<p>Convenience method to perform indexing on <code>view</code> using dimension names without knowing dimension order.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>slice | int</code> <p>slice/index to retrieve for a given dimension name</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>view_selection</code> <code>ndarray</code> <p>an ndarray-like selection of the given indices on <code>self.view</code></p>"},{"location":"docstrings/quantity/quantity/#quantity.quantity.Quantity.transpose","title":"<code>transpose(target_dims, allow_mismatch_float_precision=False)</code>","text":"<p>Change the dimension order of this Quantity.</p> <p>Parameters:</p> Name Type Description Default <code>target_dims</code> <code>Sequence[str | Iterable[str]]</code> <p>a list of output dimensions. Instead of a single dimension name, an iterable of dimensions can be used instead for any entries. For example, you may want to use X_DIMS to place an x-dimension without knowing whether it is on cell centers or interfaces.</p> required <p>Returns:</p> Name Type Description <code>transposed</code> <code>Quantity</code> <p>Quantity with the requested output dimension order</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if any of the target dimensions do not exist on this Quantity, or if this Quantity contains multiple values from an iterable entry</p> <p>Examples:</p> <p>Let's say we have a cell-centered variable:</p> <pre><code>&gt;&gt;&gt; import ndsl.util\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; quantity = Quantity(\n...     data=np.zeros([2, 3, 4]),\n...     dims=[X_DIM, Y_DIM, Z_DIM],\n...             units=\"m\",\n... )\n</code></pre> <p>If you know you are working with cell-centered variables, you can do:</p> <pre><code>&gt;&gt;&gt; from ndsl.constants import X_DIM, Y_DIM, Z_DIM\n&gt;&gt;&gt; transposed_quantity = quantity.transpose([X_DIM, Y_DIM, Z_DIM])\n</code></pre> <p>To support re-ordering without checking whether quantities are on cell centers or interfaces, the API supports giving a list of dimension names for dimensions. For example, to re-order to X-Y-Z dimensions regardless of the grid the variable is on, one could do:</p> <pre><code>&gt;&gt;&gt; from ndsl.constants import X_DIMS, Y_DIMS, Z_DIMS\n&gt;&gt;&gt; transposed_quantity = quantity.transpose([X_DIMS, Y_DIMS, Z_DIMS])\n</code></pre>"},{"location":"docstrings/quantity/state/","title":"state","text":""},{"location":"docstrings/quantity/state/#quantity.state.State","title":"<code>State</code>  <code>dataclass</code>","text":"<p>Base class for state objects in models.</p> <p>A State groups a collection of (possibly nested) Quantities in a dataclass.</p> <p>This baseclass implements common initialization functions and serialization.</p> <p>Typical usage example:</p> <pre><code>    class MyState(State):\n        pass\n\n    my_state = MyState.zeros(quantity_factory)\n\n    # ...\n\n    my_state.to_netcdf()\n</code></pre>"},{"location":"docstrings/quantity/state/#quantity.state.State.copy_memory","title":"<code>copy_memory(quantity_factory, memory_map, *, data_dimensions=None)</code>  <code>classmethod</code>","text":"<p>Allocate all quantities and fill their value based on the given memory map. See <code>update_from_memory</code>.</p> <p>Parameters:</p> Name Type Description Default <code>quantity_factory</code> <code>QuantityFactory</code> <p>factory, expected to be defined on the Grid dimensions e.g. without data dimensions.</p> required <code>memory_map</code> <code>StateMemoryMapping</code> <p>Dict of name/buffer. See <code>update_from_memory</code>.</p> required <code>data_dimensions</code> <code>dict[str, int] | None</code> <p>extra data dimensions required for any field with data dimensions. Dict of name/size pair.</p> <code>None</code>"},{"location":"docstrings/quantity/state/#quantity.state.State.empty","title":"<code>empty(quantity_factory, *, data_dimensions=None)</code>  <code>classmethod</code>","text":"<p>Allocate all quantities. Do not expect 0 on values, values are random.</p> <p>Parameters:</p> Name Type Description Default <code>quantity_factory</code> <code>QuantityFactory</code> <p>factory, expected to be defined on the Grid dimensions e.g. without data dimensions.</p> required <code>data_dimensions</code> <code>dict[str, int] | None</code> <p>extra data dimensions required for any field with data dimensions. Dict of name/size pair.</p> <code>None</code>"},{"location":"docstrings/quantity/state/#quantity.state.State.full","title":"<code>full(quantity_factory, value, *, data_dimensions=None)</code>  <code>classmethod</code>","text":"<p>Allocate all quantities and fill them with the input value</p> <p>Parameters:</p> Name Type Description Default <code>quantity_factory</code> <code>QuantityFactory</code> <p>factory, expected to be defined on the Grid dimensions e.g. without data dimensions.</p> required <code>value</code> <code>Number</code> <p>number to initialize the buffers with.</p> required <code>data_dimensions</code> <code>dict[str, int] | None</code> <p>extra data dimensions required for any field with data dimensions. Dict of name/size pair.</p> <code>None</code>"},{"location":"docstrings/quantity/state/#quantity.state.State.move_memory","title":"<code>move_memory(quantity_factory, memory_map, *, data_dimensions=None, check_shape_and_strides=True)</code>  <code>classmethod</code>","text":"<p>Allocate all quantities and move memory based on on the given memory map. See <code>update_move_memory</code>.</p> <p>Parameters:</p> Name Type Description Default <code>quantity_factory</code> <code>QuantityFactory</code> <p>factory, expected to be defined on the Grid dimensions e.g. without data dimensions.</p> required <code>memory_map</code> <code>StateMemoryMapping</code> <p>Dict of name/buffer. See <code>update_from_memory</code>.</p> required <code>data_dimensions</code> <code>dict[str, int] | None</code> <p>extra data dimensions required for any field with data dimensions. Dict of name/size pair.</p> <code>None</code> <code>check_shape_and_strides</code> <code>bool</code> <p>Check for every given buffer that the shape &amp; strides match the previously allocated memory.</p> <code>True</code>"},{"location":"docstrings/quantity/state/#quantity.state.State.ones","title":"<code>ones(quantity_factory, *, data_dimensions=None)</code>  <code>classmethod</code>","text":"<p>Allocate all quantities and fill their value to ones</p> <p>Parameters:</p> Name Type Description Default <code>quantity_factory</code> <code>QuantityFactory</code> <p>factory, expected to be defined on the Grid dimensions e.g. without data dimensions.</p> required <code>data_dimensions</code> <code>dict[str, int] | None</code> <p>extra data dimensions required for any field with data dimensions. Dict of name/size pair.</p> <code>None</code>"},{"location":"docstrings/quantity/state/#quantity.state.State.to_netcdf","title":"<code>to_netcdf(directory_path=None)</code>","text":"<p>Save state to NetCDF. Can be reloaded with <code>update_from_netcdf</code>.</p> <p>If applicable, will save separate NetCDF files for each running rank.</p> <p>The file names are deduced from the class name, and post fix with rank number in the case of a multi-process use.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path | None</code> <p>directory to save the netcdf in</p> <code>None</code>"},{"location":"docstrings/quantity/state/#quantity.state.State.update_copy_memory","title":"<code>update_copy_memory(memory_map)</code>","text":"<p>Copy data into the Quantities carried by the state.</p> <p>The memory map must follow the dataclass naming convention, e.g.</p> <p><pre><code>@dataclass\nclass MyState:\n    @dataclass\n    class InnerA\n        a: Quantity\n\n    inner_a: InnerA\n    b: Quantity\n</code></pre> will update with a dictionary looking like <pre><code>{\n    \"inner_a\":\n    {\n        \"a\": Quantity(...)\n    }\n    \"b\": Quantity(...)\n\n}\n</code></pre></p> <p>The memory map can be sparse.</p>"},{"location":"docstrings/quantity/state/#quantity.state.State.update_from_netcdf","title":"<code>update_from_netcdf(directory_path)</code>","text":"<p>This is a mirror of the <code>to_netcdf</code> method NOT a generic NetCDF loader. It expects the NetCDF to be named with the auto-naming scheme of <code>to_netcdf</code>.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>Path</code> <p>directory carrying the netcdf saved with <code>to_netcdf</code></p> required"},{"location":"docstrings/quantity/state/#quantity.state.State.update_move_memory","title":"<code>update_move_memory(memory_map, *, check_shape_and_strides=True)</code>","text":"<p>Move memory into the Quantities carried by the state. Memory is moved rather than copied (e.g. buffers are swapped)</p> <p>The memory map must follow the dataclass naming convention, e.g.</p> <p><pre><code>@dataclass\nclass MyState:\n    @dataclass\n    class InnerA\n        a: Quantity\n\n    inner_a: InnerA\n    b: Quantity\n</code></pre> will update with a dictionary looking like <pre><code>{\n    \"inner_a\":\n    {\n        \"a\": Quantity(...)\n    }\n    \"b\": Quantity(...)\n\n}\n</code></pre></p> <p>The memory map can be sparse.</p> <p>Parameters:</p> Name Type Description Default <code>memory_map</code> <code>StateMemoryMapping</code> <p>Dictionary of keys to buffers. Buffers must be np.ArrayLike</p> required <code>check_shape_and_strides</code> <code>bool</code> <p>check that the given buffers have the same shape and strides as the original quantity</p> <code>True</code>"},{"location":"docstrings/quantity/state/#quantity.state.State.zeros","title":"<code>zeros(quantity_factory, *, data_dimensions=None)</code>  <code>classmethod</code>","text":"<p>Allocate all quantities and fill their value to zeros</p> <p>Parameters:</p> Name Type Description Default <code>quantity_factory</code> <code>QuantityFactory</code> <p>factory, expected to be defined on the Grid dimensions e.g. without data dimensions.</p> required <code>data_dimensions</code> <code>dict[str, int] | None</code> <p>extra data dimensions required for any field with data dimensions. Dict of name/size pair.</p> <code>None</code>"},{"location":"docstrings/restart/_legacy_restart/","title":"_legacy_restart","text":""},{"location":"docstrings/restart/_legacy_restart/#restart._legacy_restart.open_restart","title":"<code>open_restart(dirname, communicator, label='', only_names=None, to_state=None, tracer_properties=None)</code>","text":"<p>Load restart files output by the Fortran model into a state dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dirname</code> <code>str</code> <p>location of restart files, can be local or remote</p> required <code>communicator</code> <code>Communicator</code> <p>object for communication over the cubed sphere or tile</p> required <code>label</code> <code>str</code> <p>prepended string on the restart files to load</p> <code>''</code> <code>only_names</code> <code>optional</code> <p>list of standard names to load</p> <code>None</code> <code>to_state</code> <code>optional</code> <p>if given, assign loaded data into pre-allocated quantities in this state dictionary</p> <code>None</code> <p>Returns:</p> Name Type Description <code>state</code> <p>model state dictionary</p>"},{"location":"docstrings/restart/_properties/","title":"_properties","text":"<p>:: restart._properties</p>"},{"location":"docstrings/stencils/basic_operations/","title":"basic_operations","text":""},{"location":"docstrings/stencils/basic_operations/#stencils.basic_operations.adjust_divide_stencil","title":"<code>adjust_divide_stencil(adjustment, q_out)</code>","text":"<p>Divides every element of q_out by every element of the adjustment field over the interval, replacing the elements of q_out by the result of the multiplication.</p> <p>Parameters:</p> Name Type Description Default <code>adjustment</code> <code>FloatField</code> <p>adjustment field</p> required <code>q_out</code> <code>FloatField</code> <p>output field</p> required"},{"location":"docstrings/stencils/basic_operations/#stencils.basic_operations.adjustmentfactor_stencil_defn","title":"<code>adjustmentfactor_stencil_defn(adjustment, q_out)</code>","text":"<p>Multiplies every element of q_out by every element of the adjustment field over the interval, replacing the elements of q_out by the result of the multiplication.</p> <p>Parameters:</p> Name Type Description Default <code>adjustment</code> <code>FloatFieldIJ</code> <p>adjustment field</p> required <code>q_out</code> <code>FloatField</code> <p>output field</p> required"},{"location":"docstrings/stencils/basic_operations/#stencils.basic_operations.average_in","title":"<code>average_in(q_out, adjustment)</code>","text":"<p>Averages every element of q_out with every element of the adjustment field, overwriting q_out.</p> <p>Parameters:</p> Name Type Description Default <code>adjustment</code> <code>FloatField</code> <p>adjustment field</p> required <code>q_out</code> <code>FloatField</code> <p>output field</p> required"},{"location":"docstrings/stencils/basic_operations/#stencils.basic_operations.copy_defn","title":"<code>copy_defn(q_in, q_out)</code>","text":"<p>Copy q_in to q_out.</p> <p>Parameters:</p> Name Type Description Default <code>q_in</code> <code>FloatField</code> <p>input field</p> required <code>q_out</code> <code>FloatField</code> <p>output field</p> required"},{"location":"docstrings/stencils/basic_operations/#stencils.basic_operations.dim","title":"<code>dim(a, b)</code>","text":"<p>Calculates a - b, camped to 0, i.e. max(a - b, 0).</p>"},{"location":"docstrings/stencils/basic_operations/#stencils.basic_operations.select_k","title":"<code>select_k(in_field, out_field, k_mask, k_select)</code>","text":"<p>Saves a specific k-index of a 3D field to a new 2D array. The k-value can be different for each i,j point.</p> <p>Parameters:</p> Name Type Description Default <code>in_field</code> <code>FloatField</code> <p>A 3D array to select from</p> required <code>out_field</code> <code>FloatFieldIJ</code> <p>A 2D field to save values in</p> required <code>k_mask</code> <code>IntField</code> <p>a field that lists each k-index</p> required <code>k_select</code> <code>IntFieldIJ</code> <p>the k-value to extract from in_field</p> required"},{"location":"docstrings/stencils/basic_operations/#stencils.basic_operations.set_value_defn","title":"<code>set_value_defn(q_out, value)</code>","text":"<p>Sets every element of q_out to the value specified by value argument.</p> <p>Parameters:</p> Name Type Description Default <code>q_out</code> <code>FloatField</code> <p>output field</p> required <code>value</code> <code>Float</code> <p>NDSL Float type</p> required"},{"location":"docstrings/stencils/basic_operations/#stencils.basic_operations.sign","title":"<code>sign(a, b)</code>","text":"<p>Defines a_sign_b as the absolute value of a, and checks if b is positive or negative, assigning the analogous sign value to a_sign_b. a_sign_b is returned.</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <p>A number</p> required <code>b</code> <p>A number</p> required"},{"location":"docstrings/stencils/c2l_ord/","title":"c2l_ord","text":""},{"location":"docstrings/stencils/c2l_ord/#stencils.c2l_ord.CubedToLatLon","title":"<code>CubedToLatLon</code>","text":"<p>Fortan name is c2l_ord2</p>"},{"location":"docstrings/stencils/c2l_ord/#stencils.c2l_ord.CubedToLatLon.__call__","title":"<code>__call__(u, v, ua, va)</code>","text":"<p>Interpolate D-grid to A-grid winds at latitude-longitude coordinates. Args:     u: x-wind on D-grid (in)     v: y-wind on D-grid (in)     ua: x-wind on A-grid (out)     va: y-wind on A-grid (out)     comm: Cubed-sphere or Tile communicator</p>"},{"location":"docstrings/stencils/c2l_ord/#stencils.c2l_ord.CubedToLatLon.__init__","title":"<code>__init__(state, stencil_factory, quantity_factory, grid_data, grid_type, order, comm)</code>","text":"<p>Initializes stencils to use either 2nd or 4th order of interpolation based on namelist setting Args:     stencil_factory: creates stencils     grid_data: object with metric terms     order: Order of interpolation, must be 2 or 4</p>"},{"location":"docstrings/stencils/c2l_ord/#stencils.c2l_ord.c2l_ord2","title":"<code>c2l_ord2(u, v, dx, dy, a11, a12, a21, a22, ua, va)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>u</code> <code>in</code> required <code>v</code> <code>in</code> required <code>dx</code> <code>in</code> required <code>dy</code> <code>in</code> required <code>a11</code> <code>in</code> required <code>a12</code> <code>in</code> required <code>a21</code> <code>in</code> required <code>a22</code> <code>in</code> required <code>ua</code> <code>out</code> required <code>va</code> <code>out</code> required"},{"location":"docstrings/stencils/c2l_ord/#stencils.c2l_ord.ord4_transform","title":"<code>ord4_transform(u, v, dx, dy, a11, a12, a21, a22, ua, va)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>u</code> <code>in</code> required <code>v</code> <code>in</code> required <code>dx</code> <code>in</code> required <code>dy</code> <code>in</code> required <code>a11</code> <code>in</code> required <code>a12</code> <code>in</code> required <code>a21</code> <code>in</code> required <code>a22</code> <code>in</code> required <code>ua</code> <code>out</code> required <code>va</code> <code>out</code> required"},{"location":"docstrings/stencils/corners/","title":"corners","text":""},{"location":"docstrings/stencils/corners/#stencils.corners.CopyCorners","title":"<code>CopyCorners</code>","text":"<p>Helper-class to copy corners corresponding to the fortran functions copy_corners_x or copy_corners_y respectively</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.CopyCorners.__call__","title":"<code>__call__(field)</code>","text":"<p>Fills cell quantity field using corners from itself and multipliers in the direction specified initialization of the instance of this class.</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.CopyCorners.__init__","title":"<code>__init__(direction, stencil_factory)</code>","text":"<p>The grid for this stencil</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.CopyCornersXY","title":"<code>CopyCornersXY</code>","text":"<p>Helper-class to copy corners corresponding to the Fortran functions copy_corners_x and copy_corners_y</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.CopyCornersXY.__call__","title":"<code>__call__(field)</code>","text":"<p>Fills cell quantity field using corners from itself.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>FloatField</code> <p>field to fill corners</p> required <p>Returns:</p> Name Type Description <code>x_differenceable</code> <p>input field, updated so it can be differenced in x-direction</p> <code>y_differenceable</code> <p>copy of input field which can be differenced in y-direction</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.CopyCornersXY.__init__","title":"<code>__init__(stencil_factory, dims, y_field)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>stencil_factory</code> <code>StencilFactory</code> <p>creates stencils</p> required <code>dims</code> <code>Sequence[str]</code> <p>dimensionality of the data to be copied</p> required <code>y_field</code> <p>3D gt4py storage to use for y-differenceable field (x-differenceable field uses same memory as base field)</p> required"},{"location":"docstrings/stencils/corners/#stencils.corners.FillCornersBGrid","title":"<code>FillCornersBGrid</code>","text":"<p>Helper-class to fill corners corresponding to the fortran function fill_corners with BGRID=.true. and either FILL=YDir or FILL=YDIR</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.fill_corners_2cells_mult_x","title":"<code>fill_corners_2cells_mult_x(q, q_corner, sw_mult, se_mult, nw_mult, ne_mult)</code>","text":"<p>Fills cell quantity q using corners from q_corner and multipliers in x-dir.</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.fill_corners_2cells_mult_y","title":"<code>fill_corners_2cells_mult_y(q, q_corner, sw_mult, se_mult, nw_mult, ne_mult)</code>","text":"<p>Fills cell quantity q using corners from q_corner and multipliers in y-dir.</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.fill_corners_2cells_x","title":"<code>fill_corners_2cells_x(q)</code>","text":"<p>Fills cell quantity q in x-dir.</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.fill_corners_2cells_y","title":"<code>fill_corners_2cells_y(q)</code>","text":"<p>Fills cell quantity q in y-dir.</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.fill_corners_3cells_mult_x","title":"<code>fill_corners_3cells_mult_x(q, q_corner, sw_mult, se_mult, nw_mult, ne_mult)</code>","text":"<p>Fills cell quantity q using corners from q_corner and multipliers in x-dir.</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.fill_corners_3cells_mult_y","title":"<code>fill_corners_3cells_mult_y(q, q_corner, sw_mult, se_mult, nw_mult, ne_mult)</code>","text":"<p>Fills cell quantity q using corners from q_corner and multipliers in y-dir.</p>"},{"location":"docstrings/stencils/corners/#stencils.corners.fill_corners_dgrid_defn","title":"<code>fill_corners_dgrid_defn(x_in, x_out, y_in, y_out, mysign)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>x_in</code> <code>in</code> required <code>x_out</code> <code>inout</code> required <code>y_in</code> <code>in</code> required <code>y_out</code> <code>inout</code> required"},{"location":"docstrings/stencils/tridiag/","title":"tridiag","text":""},{"location":"docstrings/stencils/tridiag/#stencils.tridiag.masked_tridiag_solve","title":"<code>masked_tridiag_solve(a, b, c, d, x, delta, mask)</code>","text":"<p>Same as tridiag_solve but restricted to a subset of horizontal points</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>in</code> <p>lower-diagonal matrix coefficients</p> required <code>b</code> <code>in</code> <p>diagonal matrix coefficients</p> required <code>c</code> <code>in</code> <p>upper-diagonal matrix coefficients</p> required <code>d</code> <code>in</code> <p>Result vector</p> required <code>mask</code> <code>in</code> <p>Columns to execute the stencil on</p> required <code>x</code> <code>out</code> <p>The vector to solve for</p> required <code>delta</code> <code>out</code> <p>d post-pivot</p> required"},{"location":"docstrings/stencils/tridiag/#stencils.tridiag.tridiag_solve","title":"<code>tridiag_solve(a, b, c, d, x, delta)</code>","text":"<p>This stencil solves a square, k x k tridiagonal matrix system with coefficients a, b, and c, and vectors p and d using the Thomas algorithm: ! ###                                            ### ###  ###   ###  ###! ! #b(0), c(0),  0  ,  0  ,  0  ,   . . .  ,    0   # # x(0) #   # d(0) #! ! #a(1), b(1), c(1),  0  ,  0  ,   . . .  ,    0   # # x(1) #   # d(1) #! ! # 0  , a(2), b(2), c(2),  0  ,   . . .  ,    0   # # x(2) #   # d(2) #! ! # 0  ,  0  , a(3), b(3), c(3),   . . .  ,    0   # # x(3) #   # d(3) #! ! # 0  ,  0  ,  0  , a(4), b(4),   . . .  ,    0   # # x(4) #   # d(4) #! ! # .                                          .   # #  .   # = #   .  #! ! # .                                          .   # #  .   #   #   .  #! ! # .                                          .   # #  .   #   #   .  #! ! # 0  , . . . , 0 , a(k-2), b(k-2), c(k-2),   0   # #x(k-3)#   #d(k-3)#! ! # 0  , . . . , 0 ,   0   , a(k-1), b(k-1), c(k-1)# #x(k-2)#   #d(k-2)#! ! # 0  , . . . , 0 ,   0   ,   0   ,  a(k) ,  b(k) # #x(k-1)#   #d(k-1)#! ! ###                                            ### ###  ###   ###  ###!</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>in</code> <p>lower-diagonal matrix coefficients</p> required <code>b</code> <code>in</code> <p>diagonal matrix coefficients</p> required <code>c</code> <code>in</code> <p>upper-diagonal matrix coefficients</p> required <code>d</code> <code>in</code> <p>Result vector</p> required <code>x</code> <code>out</code> <p>The vector to solve for</p> required <code>delta</code> <code>out</code> <p>d post-pivot</p> required"},{"location":"docstrings/testing/comparison/","title":"comparison","text":""},{"location":"docstrings/testing/comparison/#testing.comparison.LegacyMetric","title":"<code>LegacyMetric</code>","text":"<p>               Bases: <code>BaseMetric</code></p> <p>Legacy (AI2) metric used for original FV3 port.</p> <p>This metric attempts to smooth error comparison around 0. It further tries to deal with close-to-0 breakdown of absolute error by allowing <code>near_zero</code> threshold to be specified by hand.</p>"},{"location":"docstrings/testing/comparison/#testing.comparison.MultiModalFloatMetric","title":"<code>MultiModalFloatMetric</code>","text":"<p>               Bases: <code>BaseMetric</code></p> <p>Combination of absolute, relative &amp; ULP comparison for floats</p> <p>This metric attempts to combine well known comparison on floats to leverage a robust 32/64 bit float comparison on large accumulating floating errors.</p> <p>ULP is used to clear noise (ULP&lt;=1.0 passes) Absolute errors for large amplitude</p>"},{"location":"docstrings/testing/dummy_comm/","title":"dummy_comm","text":""},{"location":"docstrings/testing/perturbation/","title":"perturbation","text":""},{"location":"docstrings/testing/perturbation/#testing.perturbation.perturb","title":"<code>perturb(input)</code>","text":"<p>Adds roundoff-level noise to the input array in-place through multiplication.</p> <p>Will only make changes to float64 or float32 arrays.</p>"},{"location":"docstrings/top/boilerplate/","title":"boilerplate","text":""},{"location":"docstrings/top/boilerplate/#boilerplate.get_factories_single_tile","title":"<code>get_factories_single_tile(nx, ny, nz, nhalo, backend='numpy')</code>","text":"<p>Build the pair of (StencilFactory, QuantityFactory) for stencils on a single tile topology.</p>"},{"location":"docstrings/top/boilerplate/#boilerplate.get_factories_single_tile_orchestrated","title":"<code>get_factories_single_tile_orchestrated(nx, ny, nz, nhalo, backend='dace:cpu')</code>","text":"<p>Build the pair of (StencilFactory, QuantityFactory) for orchestrated code on a single tile topology.</p>"},{"location":"docstrings/top/buffer/","title":"buffer","text":""},{"location":"docstrings/top/buffer/#buffer.Buffer","title":"<code>Buffer</code>","text":"<p>A buffer cached by default.</p> <p>_key: key into cache storage to allow easy re-caching array: ndarray allocated</p>"},{"location":"docstrings/top/buffer/#buffer.Buffer.__init__","title":"<code>__init__(key, array)</code>","text":"<p>Init a cacheable buffer.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>BufferKey</code> <p>a cache key made out of tuple of Allocator, shape and dtype</p> required <code>array</code> <code>ndarray</code> <p>ndarray of actual data</p> required"},{"location":"docstrings/top/buffer/#buffer.Buffer.assign_from","title":"<code>assign_from(source_array, buffer_slice=np.index_exp[:])</code>","text":"<p>Assign source_array to internal array.</p> <p>Parameters:</p> Name Type Description Default <code>source_array</code> <code>ndarray</code> <p>source ndarray</p> required"},{"location":"docstrings/top/buffer/#buffer.Buffer.assign_to","title":"<code>assign_to(destination_array, buffer_slice=np.index_exp[:], buffer_reshape=None)</code>","text":"<p>Assign internal array to destination_array.</p> <p>Parameters:</p> Name Type Description Default <code>destination_array</code> <code>ndarray</code> <p>target ndarray</p> required"},{"location":"docstrings/top/buffer/#buffer.Buffer.finalize_memory_transfer","title":"<code>finalize_memory_transfer()</code>","text":"<p>Finalize any memory transfer</p>"},{"location":"docstrings/top/buffer/#buffer.Buffer.pop_from_cache","title":"<code>pop_from_cache(allocator, shape, dtype)</code>  <code>classmethod</code>","text":"<p>Retrieve or insert then retrieve of buffer from cache.</p> <p>Parameters:</p> Name Type Description Default <code>allocator</code> <code>Allocator</code> <p>used to allocate memory</p> required <code>shape</code> <code>Iterable[int]</code> <p>shape of array</p> required <code>dtype</code> <code>type</code> <p>type of array elements</p> required <p>Return:     a buffer wrapping an allocated array</p>"},{"location":"docstrings/top/buffer/#buffer.Buffer.push_to_cache","title":"<code>push_to_cache(buffer)</code>  <code>staticmethod</code>","text":"<p>Push the buffer back into the cache.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>Buffer</code> <p>buffer to push back in cache, using internal key</p> required"},{"location":"docstrings/top/buffer/#buffer.array_buffer","title":"<code>array_buffer(allocator, shape, dtype)</code>","text":"<p>A context manager providing a contiguous array, which may be re-used between calls.</p> <p>Parameters:</p> Name Type Description Default <code>allocator</code> <code>Allocator</code> <p>a function with the same signature as numpy.zeros which returns an ndarray</p> required <code>shape</code> <code>Iterable[int]</code> <p>the shape of the desired array</p> required <code>dtype</code> <code>type</code> <p>the dtype of the desired array</p> required <p>Yields:</p> Name Type Description <code>buffer_array</code> <code>Buffer</code> <p>an ndarray created according to the specification in the args. May be retained and re-used in subsequent calls.</p>"},{"location":"docstrings/top/buffer/#buffer.recv_buffer","title":"<code>recv_buffer(allocator, array, timer=None)</code>","text":"<p>A context manager ensuring that array is contiguous in a context where it is being used to receive data, using a recycled buffer array and then copying the result into array if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>allocator</code> <code>Callable</code> <p>used to allocate memory</p> required <code>array</code> <code>ndarray</code> <p>a possibly non-contiguous array for which to provide a buffer</p> required <code>timer</code> <code>Timer | None</code> <p>object to accumulate timings for \"unpack\"</p> <code>None</code> <p>Yields:</p> Name Type Description <code>buffer_array</code> <code>ndarray</code> <p>if array is non-contiguous, a contiguous buffer array which is copied into array when the context is exited. Otherwise, yields array.</p>"},{"location":"docstrings/top/buffer/#buffer.send_buffer","title":"<code>send_buffer(allocator, array, timer=None)</code>","text":"<p>A context manager ensuring that <code>array</code> is contiguous in a context where it is being sent as data, copying into a recycled buffer array if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>allocator</code> <code>Callable</code> <p>used to allocate memory</p> required <code>array</code> <code>ndarray</code> <p>a possibly non-contiguous array for which to provide a buffer</p> required <code>timer</code> <code>Timer | None</code> <p>object to accumulate timings for \"pack\"</p> <code>None</code> <p>Yields:</p> Name Type Description <code>buffer_array</code> <code>ndarray</code> <p>if array is non-contiguous, a contiguous buffer array containing the data from array. Otherwise, yields array.</p>"},{"location":"docstrings/top/constants/","title":"constants","text":""},{"location":"docstrings/top/constants/#constants.CP_VAP","title":"<code>CP_VAP = Float(4.0) * RVGAS</code>  <code>module-attribute</code>","text":"<p>Heat capacity of water vapor at constant pressure</p>"},{"location":"docstrings/top/constants/#constants.CV_AIR","title":"<code>CV_AIR = CP_AIR - RDGAS</code>  <code>module-attribute</code>","text":"<p>Heat capacity of dry air at constant volume</p>"},{"location":"docstrings/top/constants/#constants.CV_VAP","title":"<code>CV_VAP = Float(3.0) * RVGAS</code>  <code>module-attribute</code>","text":"<p>Heat capacity of water vapor at constant volume</p>"},{"location":"docstrings/top/constants/#constants.C_ICE","title":"<code>C_ICE = Float(1972.0)</code>  <code>module-attribute</code>","text":"<p>Heat capacity of ice at -15 degrees Celsius</p>"},{"location":"docstrings/top/constants/#constants.C_ICE_0","title":"<code>C_ICE_0 = Float(2106.0)</code>  <code>module-attribute</code>","text":"<p>Heat capacity of ice at 0 degrees Celsius</p>"},{"location":"docstrings/top/constants/#constants.C_LIQ","title":"<code>C_LIQ = Float(4185.5)</code>  <code>module-attribute</code>","text":"<p>Heat capacity of water at 15 degrees Celsius</p>"},{"location":"docstrings/top/constants/#constants.D2ICE","title":"<code>D2ICE = DC_VAP + DC_ICE</code>  <code>module-attribute</code>","text":"<p>Isobaric heating / cooling</p>"},{"location":"docstrings/top/constants/#constants.DC_ICE","title":"<code>DC_ICE = C_LIQ - C_ICE</code>  <code>module-attribute</code>","text":"<p>Isobaric heating / cooling</p>"},{"location":"docstrings/top/constants/#constants.DC_VAP","title":"<code>DC_VAP = CP_VAP - C_LIQ</code>  <code>module-attribute</code>","text":"<p>Isobaric heating / cooling</p>"},{"location":"docstrings/top/constants/#constants.E00","title":"<code>E00 = Float(611.21)</code>  <code>module-attribute</code>","text":"<p>Saturation vapor pressure at 0 degrees Celsius (Pa)</p>"},{"location":"docstrings/top/constants/#constants.GRAV","title":"<code>GRAV = Float(9.80665)</code>  <code>module-attribute</code>","text":"<p>Acceleration due to gravity [m/s^2].04</p>"},{"location":"docstrings/top/constants/#constants.HLF","title":"<code>HLF = Float(333700.0)</code>  <code>module-attribute</code>","text":"<p>Latent heat of fusion [J/kg]  ~3.34e5</p>"},{"location":"docstrings/top/constants/#constants.HLV","title":"<code>HLV = Float(2466500.0)</code>  <code>module-attribute</code>","text":"<p>Latent heat of evaporation [J/kg]</p>"},{"location":"docstrings/top/constants/#constants.KAPPA","title":"<code>KAPPA = RDGAS / (Float(3.5) * RDGAS)</code>  <code>module-attribute</code>","text":"<p>Specific heat capacity of dry air at</p>"},{"location":"docstrings/top/constants/#constants.LAT2","title":"<code>LAT2 = np.power(HLV + HLF, 2, dtype=Float)</code>  <code>module-attribute</code>","text":"<p>Used in bigg mechanism</p>"},{"location":"docstrings/top/constants/#constants.LI00","title":"<code>LI00 = HLF - DC_ICE * TICE</code>  <code>module-attribute</code>","text":"<p>-2.7105966e5, fusion latent heat coefficient at 0 degrees Kelvin</p>"},{"location":"docstrings/top/constants/#constants.LI2","title":"<code>LI2 = LV0 + LI00</code>  <code>module-attribute</code>","text":"<p>2.86799816e6, sublimation latent heat coefficient at 0 degrees Kelvin</p>"},{"location":"docstrings/top/constants/#constants.LV0","title":"<code>LV0 = HLV - DC_VAP * TICE</code>  <code>module-attribute</code>","text":"<p>3.13905782e6, evaporation latent heat coefficient at 0 degrees Kelvin</p>"},{"location":"docstrings/top/constants/#constants.OMEGA","title":"<code>OMEGA = Float(2.0) * PI / Float(86164.0)</code>  <code>module-attribute</code>","text":"<p>Rotation of the earth</p>"},{"location":"docstrings/top/constants/#constants.PSAT","title":"<code>PSAT = Float(610.78)</code>  <code>module-attribute</code>","text":"<p>Saturation vapor pressure at H2O 3pt (Pa)</p>"},{"location":"docstrings/top/constants/#constants.RADIUS","title":"<code>RADIUS = Float(6371000.0)</code>  <code>module-attribute</code>","text":"<p>Radius of the Earth [m]</p>"},{"location":"docstrings/top/constants/#constants.RDGAS","title":"<code>RDGAS = Float(8314.47) / Float(28.965)</code>  <code>module-attribute</code>","text":"<p>Gas constant for dry air [J/kg/deg] ~287.04</p>"},{"location":"docstrings/top/constants/#constants.RGRAV","title":"<code>RGRAV = Float(1.0) / GRAV</code>  <code>module-attribute</code>","text":"<p>Inverse of gravitational acceleration</p>"},{"location":"docstrings/top/constants/#constants.RHO_H2O","title":"<code>RHO_H2O = Float(1000.0)</code>  <code>module-attribute</code>","text":"<p>Density of water in kg/m^3</p>"},{"location":"docstrings/top/constants/#constants.RVGAS","title":"<code>RVGAS = Float(8314.47) / Float(18.015)</code>  <code>module-attribute</code>","text":"<p>Gas constant for water vapor [J/kg/deg]</p>"},{"location":"docstrings/top/constants/#constants.SBC","title":"<code>SBC = Float(5.6704e-08)</code>  <code>module-attribute</code>","text":"<p>Stefan-Boltzmann constant (W/m^2/K^4)</p>"},{"location":"docstrings/top/constants/#constants.TFREEZE","title":"<code>TFREEZE = Float(273.16)</code>  <code>module-attribute</code>","text":"<p>Freezing temperature of fresh water [K]</p>"},{"location":"docstrings/top/constants/#constants.TICE","title":"<code>TICE = Float(273.16)</code>  <code>module-attribute</code>","text":"<p>Freezing temperature</p>"},{"location":"docstrings/top/constants/#constants.TICE0","title":"<code>TICE0 = Float(273.15)</code>  <code>module-attribute</code>","text":"<p>Temp at 0C</p>"},{"location":"docstrings/top/constants/#constants.TTP","title":"<code>TTP = Float(273.16)</code>  <code>module-attribute</code>","text":"<p>Temperature of H2O triple point</p>"},{"location":"docstrings/top/constants/#constants.T_MIN","title":"<code>T_MIN = Float(178.0)</code>  <code>module-attribute</code>","text":"<p>Minimum temperature to freeze-dry all water vapor</p>"},{"location":"docstrings/top/constants/#constants.T_SAT_MIN","title":"<code>T_SAT_MIN = TICE - Float(160.0)</code>  <code>module-attribute</code>","text":"<p>Minimum temperature used in saturation calculations</p>"},{"location":"docstrings/top/constants/#constants.T_WFR","title":"<code>T_WFR = TICE - Float(40.0)</code>  <code>module-attribute</code>","text":"<p>homogeneous freezing temperature</p>"},{"location":"docstrings/top/constants/#constants.ZVIR","title":"<code>ZVIR = RVGAS / RDGAS - Float(1)</code>  <code>module-attribute</code>","text":"<p>con_fvirt in Fortran physics</p>"},{"location":"docstrings/top/io/","title":"io","text":""},{"location":"docstrings/top/io/#io.read_state","title":"<code>read_state(filename)</code>","text":"<p>Read a model state from a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>local or remote location of the NetCDF file</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>dict</code> <p>a model state dictionary</p>"},{"location":"docstrings/top/io/#io.write_state","title":"<code>write_state(state, filename)</code>","text":"<p>Write a model state to a NetCDF file.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>dict</code> <p>a model state dictionary</p> required <code>filename</code> <code>str</code> <p>local or remote location to write the NetCDF file</p> required"},{"location":"docstrings/top/logging/","title":"logging","text":""},{"location":"docstrings/top/optional_imports/","title":"optional_imports","text":""},{"location":"docstrings/top/types/","title":"types","text":""},{"location":"docstrings/top/types/#types.AsyncRequest","title":"<code>AsyncRequest</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Define the result of an over-the-network capable communication API</p>"},{"location":"docstrings/top/types/#types.AsyncRequest.wait","title":"<code>wait()</code>","text":"<p>Block the current thread waiting for the request to be completed</p>"},{"location":"docstrings/top/typing/","title":"typing","text":""},{"location":"docstrings/top/utils/","title":"utils","text":""},{"location":"docstrings/top/utils/#utils.device_synchronize","title":"<code>device_synchronize()</code>","text":"<p>Synchronize all memory communication</p>"},{"location":"docstrings/top/utils/#utils.f90nml_as_dict","title":"<code>f90nml_as_dict(nml, flatten=True, target_groups=None)</code>","text":"<p>Uses a f90nml.Namelist and returns a dict representation. If target_groups are specified, then the dict is created using only those groups. The return dicts can be flattened further to remove the group information or keep the group information.</p> <p>Parameters:</p> Name Type Description Default <code>nml</code> <code>Namelist</code> <p>f90nml.Namelist</p> required <code>flatten</code> <code>bool</code> <p>If True, flattens the loaded namelist (without groups) before      returning it. (Default: True) Otherwise, it returns the f90nml.Namelist      dict representation.</p> <code>True</code> <code>target_groups</code> <code>list[str] | None</code> <p>If 'None' is specified, then all groups are            considered. (Default: None) Otherwise, only parameters            from the specified groups are considered.</p> <code>None</code>"},{"location":"docstrings/top/utils/#utils.flatten_nml_to_dict","title":"<code>flatten_nml_to_dict(nml)</code>","text":"<p>Returns a flattened dict version of a f90nml.namelist.Namelist</p> <p>Parameters:</p> Name Type Description Default <code>nml</code> <code>Namelist</code> <p>f90nml.Namelist</p> required"},{"location":"docstrings/top/utils/#utils.grid_params_from_f90nml","title":"<code>grid_params_from_f90nml(nml)</code>","text":"<p>Uses a f90nml.Namelist and returns a dict representation of parameters useful for grid generation. The return dict will be flattened with key-value pairs from the nml's DEFAULT_GRID_NML_GROUPS.</p> <p>Parameters:</p> Name Type Description Default <code>nml</code> <code>Namelist</code> <p>f90nml.Namelist</p> required"},{"location":"docstrings/top/utils/#utils.list_by_dims","title":"<code>list_by_dims(dims, horizontal_list, non_horizontal_value)</code>","text":"<p>Take in a list of dimensions, a (y, x) set of values, and a value for any non-horizontal dimensions. Return a list of length len(dims) with the value for each dimension.</p>"},{"location":"docstrings/top/utils/#utils.load_f90nml","title":"<code>load_f90nml(namelist_path)</code>","text":"<p>Loads a Fortran namelist given its path and return a f90nml.Namelist</p> <p>Parameters:</p> Name Type Description Default <code>namelist_path</code> <code>Path</code> <p>Path to the Fortran namelist file</p> required"},{"location":"docstrings/top/utils/#utils.load_f90nml_as_dict","title":"<code>load_f90nml_as_dict(namelist_path, flatten=True, target_groups=None)</code>","text":"<p>Loads a Fortran namelist given its path and returns a dict representation. If target_groups are specified, then the dict is created using only those groups.</p> <p>Parameters:</p> Name Type Description Default <code>namelist_path</code> <code>Path</code> <p>Path to the Fortran namelist file</p> required <code>flatten</code> <code>bool</code> <p>If True, flattens the loaded namelist (without groups) before      returning it. (Default: True) Otherwise, it returns the f90nml.Namelist      dict representation.</p> <code>True</code> <code>target_groups</code> <code>list[str] | None</code> <p>If 'None' is specified, then all groups are            considered. (Default: None) Otherwise, only parameters            from the specified groups are considered.</p> <code>None</code>"},{"location":"docstrings/top/utils/#utils.safe_assign_array","title":"<code>safe_assign_array(to_array, from_array)</code>","text":"<p>Failproof assignment for array on different devices.</p> <p>The memory will be downloaded/uploaded from GPU if need be.</p> <p>Parameters:</p> Name Type Description Default <code>to_array</code> <code>ndarray</code> <p>destination ndarray</p> required <code>from_array</code> <code>ndarray</code> <p>source ndarray</p> required"},{"location":"docstrings/top/utils/#utils.safe_mpi_allocate","title":"<code>safe_mpi_allocate(allocator, shape, dtype)</code>","text":"<p>Make sure the allocation use an allocator that works with MPI</p> <p>For G2G transfer, MPICH requires the allocation to not be done with managed memory. Since we can't know what state <code>cupy</code> is in with switch for the default pooled allocator.</p> <p>If allocator comes from cupy, it must be cupy.empty or cupy.zeros. We raise a RuntimeError if a cupy array is allocated outside of the safe code path.</p> <p>Though the allocation might be safe, the MPI crash that result from a managed memory allocation is non trivial and should be tightly controlled.</p>"},{"location":"docstrings/viz/cube_sphere/","title":"cube_sphere","text":""},{"location":"includes/glossary/","title":"Glossary","text":""},{"location":"porting/","title":"Notes on porting FORTRAN code","text":"<p>This part of the documentation includes notes about porting FORTRAN code to NDSL.</p>"},{"location":"porting/#general-concepts","title":"General Concepts","text":"<p>Since we are not trying to do model developing but rather replicate an existing model, the main philosophy is to replicate model behavior as precisely as possible. Since weather and climate models can take diverging paths based on very small input differences, as described in [1], a bitwise reproducible code is impossible to achieve. There were attempts at solving this problem like shown in [2] or [3] but all of those require heavy modification to the original code. In our case, the switch from the original FORTRAN environment to a C++ environment can already contribute to these small errors showing up and therefore a 1:1 validation on a large scale is impossible. This effect gets further enhanced by computation on GPUs. Lastly the mixing of precisions found in various models is often done slightly unmethodical and can further complicate the understand of what precision is required where.</p> <p>Since large scale validation is therefore close to impossible, we are trying to get reproducible results (within a margin) on smaller sub-components of the model. When porting code, we therefore try to break down larger components into logical, numerically coherent substructures that can be tested and validated individually. This breakdown serves two main purposes:</p> <ol> <li>Give us confidence, that the ported code behaves as intended.</li> <li>Allow us to monitor if or how performance optimization down the road changes the numerical results of our model components.</li> </ol>"},{"location":"porting/#porting-guidelines","title":"Porting Guidelines","text":"<p>Since GT4Py has certain restrictions on what can be in the same stencil and what needs to be in separate stencils, there is no absolute 1:1 mapping that can or should be applied.</p> <p>The best practices we found are:</p> <ol> <li>A numerically self-contained module should always live in a single class.</li> <li>If possible, try to isolate individual numerical motifs into functions.</li> </ol>"},{"location":"porting/#example","title":"Example","text":"<p>To illustrate best practices, we show a stripped version of the the nonhydrostatic vertical solver on the C-grid (Also know as the Riemann Solver):</p>"},{"location":"porting/#main-definition","title":"Main definition","text":"<pre><code>class NonhydrostaticVerticalSolverCGrid:\n    def __init__(self, ...):\n        # Definition of the (potentially multiple) stencils to call\n        self._precompute_stencil = stencil_factory.from_origin_domain(\n            precompute,\n            origin=origin,\n            domain=domain,\n        )\n        self._compute_sim1_solve = stencil_factory.from_origin_domain(\n            sim1_solver,\n            origin=origin,\n            domain=domain,\n        )\n        # Definition of temporary variables share across two stencils\n        # that are not used outside the module\n        self._pfac = FloatFieldIJ()\n        ...\n    def __call__(self, cappa: FloatField, delpc: FloatField):\n        self._precompute_stencil(cappa, _pfac)\n        self._compute_sim1_solve(_pfac, delpc)\n</code></pre>"},{"location":"porting/#stencil-definitions","title":"Stencil Definitions","text":"<pre><code>#constants definition\nc1 = Float(-2.0) / Float(14.0)\nc2 = Float(11.0) / Float(14.0)\nc3 = Float(5.0) / Float(14.0)\n\n#function for numerical standalone motif\n@gtscript.function\ndef vol_conserv_cubic_interp_func_y(v):\n    return c1 * v[0, -2, 0] + c2 * v[0, -1, 0] + c3 * v\n\ndef precompute(cappa: FloatField, _pfac: FloatFieldIJ):\n    # small computation directly in the stencil\n    with computation(PARALLEL), interval(...):\n        # a variable used only in one stencil can be defined here\n        tmpvar = cappa[1,0,0] + 1\n    with computation(PARALLEL), interval(0, 1):\n        _pfac = tmpvar[0,0,1]\n\ndef sim1_solver(cappa: FloatField, _pfac: FloatFieldIJ):\n    with computation(PARALLEL), interval(...):\n        cappa = vol_conserv_cubic_interp_func_y(cappa) + _pfac\n</code></pre>"},{"location":"porting/translate/","title":"Translate tests","text":"<p>We call tests that validate subsets of computation against serialized data \"translate tests\". These should provide a baseline with which we can validate ported code and ensure the pipeline generates expected results.</p>"},{"location":"porting/translate/#the-translate-infrastructure","title":"The Translate infrastructure","text":"<p>The infrastructure is set up in a way that for basic cases, all the default implementations are enough:</p> <p>The <code>TranslateFortranData2Py</code> base class will be evaluated through the function <code>test_sequential_savepoint</code>. The general structure is:</p> <ol> <li>Extract tolerances for errors - either the defaults or the overwritten ones:<ul> <li>Maximal absolute error</li> <li>Maximal relative error</li> <li>Allowed ULP difference</li> </ul> </li> <li>Extract input data from <code>{savepoint_name}-In.nc</code></li> <li>Run the <code>compute</code> function, returning the outputs.</li> <li>Extract reference output data from <code>{savepoint_name}-Out.nc</code></li> <li>Compare the data in <code>out_vars</code> to the reference data.</li> </ol> <p>For these steps to work, the name of the translate test needs to match the name of the data. In case of special handling required, almost everything can be overwritten:</p>"},{"location":"porting/translate/#overwriting-thresholds","title":"Overwriting thresholds","text":"<p>You can create an overwrite file to manually set the threshold in you data directory:</p> <p></p>"},{"location":"porting/translate/#testing-with-custom-data","title":"Testing with Custom Data","text":"<p>The default netcdf names can be overwritten by setting <code>self.override_input_netcdf_name</code> and/or <code>self.override_output_netcdf_name</code> for the input and output netcdf, respectively. These new names should be the entire file name (including, but not requiring, -In or -Out suffixes), excluding the <code>.nc</code> file tag. These files must be located in the same folder as the default files.</p>"},{"location":"porting/translate/#overwriting-arguments-to-your-compute-function","title":"Overwriting Arguments to your compute function","text":"<p>The compute_func will be called automatically in the test. If your names in the netcdf are matching the <code>kwargs</code> of your function directly, no further action required:</p> <p></p> <p>If you need to rename it from the netcdf, you can use [\"serialname\"]:</p> <p></p> <p>The same applies for scalar inputs with parameters:</p> <p></p>"},{"location":"porting/translate/#modifying-output-variables","title":"Modifying output variables","text":"<p>This can be required either if not all output is serialized, the naming is different or we need the same data as the input:</p> <p></p>"},{"location":"porting/translate/#modifying-the-compute-function","title":"Modifying the <code>compute</code> function","text":"<p>Normally, compute has the three steps:</p> <ol> <li>setup input</li> <li>call <code>compute_func</code></li> <li>slice outputs</li> </ol> <p>Slight adaptations to every step are possible:</p> <p></p>"},{"location":"user/","title":"Usage documentation","text":"<p>This part of the documentation is geared towards users of NDSL.</p>"},{"location":"user/#up-and-running","title":"Up and running","text":"<p>See our quickstart guide on how to get up and running.</p>"},{"location":"user/#configuration","title":"Configuration","text":"<p>NDSL tries to have sensible defaults. In cases you want tweak something, here are some pointers:</p>"},{"location":"user/#literal-precision-floatint","title":"Literal precision (float/int)","text":"<p>Unspecified integer and floating point literals (e.g. <code>42</code> and <code>3.1415</code>) default to 64-bit precision. This can be changed with the environment variable <code>NDSL_LITERAL_PRECISION</code>.</p> <p>For mixed precision code, you can specify the \"hard coded\" precision with type hints and casts, e.g.</p> <pre><code>with computation(PARALLEL), interval(...):\n    # Either 32-bit or 64-bit depending on `NDSL_LITERAL_PRECISION`\n    my_int = 42\n    my_float = 3.1415\n\n    # Always 32-bit\n    my_int32: int32 = 42\n    my_float32: float32 = 3.1415\n\n    # Explicit 64-bit cast within otherwise unspecified calculation\n    factor = 0.5 * float64(3.1415 + 2.71828)\n</code></pre>"},{"location":"user/#full-program-optimizer","title":"Full program optimizer","text":"<p>The behavior of the full program optimizer is controlled by <code>FV3_DACEMODE</code>. Valid values are:</p> <code>Python</code> <p>The default. Disables full program optimization and only accelerates stencil code.</p> <code>Build</code> <p>Build the program, then exit. This mode is only available for backends <code>dace:gpu</code> and <code>dace:cpu</code>.</p> <code>BuildAndRun</code> <p>Build the program, then run it immediately. This mode is only available for backends <code>dace:gpu</code> and <code>dace:cpu</code>.</p> <code>Run</code> <p>Load a pre-compiled program and run it. Fails if the pre-compiled program can not be found. This mode is only available for backends <code>dace:gpu</code> and <code>dace:cpu</code>.</p>"}]}